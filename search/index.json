[{"content":"欢迎来到我的博客！\nInfo\r《CommunityToolkit.Mvvm 社区工具包从入门到精通》系列教程已经基本完工！你可以点击这里查看，并在评论区留下你的宝贵意见。\r虽然博客的绝大多数所需功能都已经实现，但仍有一些细节需要微调，比如：\n右侧目录宽度太大 博客正文的标题下方不需要显示摘要内容 添加用户访问统计 阅读时长的计算并不十分准确 去掉文章小标题前面的“#”号 添加 RSS 订阅功能 添加一个「关于我」页面 添加评论区 更多关于我的信息，请查看关于我页面。\n本博客使用 Hugo 搭建，主题是 Stack。\n封面图片使用 Fooocus 绘制。\n","date":"2024-02-18T00:00:00Z","image":"https://blog.coldwind.top/posts/hello-world/cover_hu_c13d4bbd8c4b8e43.jpg","permalink":"https://blog.coldwind.top/posts/hello-world/","title":"你好，世界！"},{"content":" 本文有对应的视频教程：哔哩哔哩\n我们常说，密码不能明文存储在数据库中，而是应当哈希后存储。尤其我们还要对密码进行加盐处理。这样做的目的及必要性是什么呢？在 C# 中又该如何实现呢？这篇文章我们就来探讨一下。我们将从最不安全到最安全，逐步讲解为什么要这样做。\n明文存储 \u0026para; 首先我们就来看一看最不安全的方式吧：\n1 2 3 4 5 6 class User { public int Id { get; set; } // 自增主键 public string Username { get; set; } public string Password { get; set; } // 明文密码 } 然后我们去创建一个用户：\n1 2 3 4 5 var user = new User { Username = \u0026#34;admin\u0026#34;, Password = \u0026#34;123456\u0026#34; }; 那么现在，数据库中存储的就是用户的明文密码了。这样其实是非常危险的。\n假如是本地的如 SQLite 数据库，那么只要有人能够访问到数据库文件，或通过反编译等方式获取到了连接字符串，那么就可以直接看到用户的密码； 假如是远程的数据库，那么黑客依旧有多种方式可以获取到数据库的数据，比如 SQL 注入、SSH 密钥泄露、数据库备份文件泄露、其他服务器漏洞等等。 明文的密码可以说是相当不应该被泄露的。它不仅可能包含了用户的私密信息以及使用习惯，还可以被黑客直接用来撞库（即通过泄露的密码尝试登录其他网站）。所以我们应当在任何情况下避免明文存储密码。\n哈希存储（MD5 / SHA1） \u0026para; 下面我们稍微升级一下我们的代码，改为存储使用 MD5 或 SHA1 哈希后的密码：\n1 2 3 4 5 6 class User { public int Id { get; set; } // 自增主键 public string Username { get; set; } public string PasswordHash { get; set; } // 密码哈希 } 然后为了方便开发，我们再写一个密码辅助类，用来进行密码哈希及验证：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class PasswordHelper { public static string HashPassword(string password) { using var md5 = MD5.Create(); var hash = md5.ComputeHash(Encoding.UTF8.GetBytes(password)); return Convert.ToBase64String(hash); } public static bool VerifyPassword(string password, string passwordHash) { return HashPassword(password) == passwordHash; } } 在这个方法中，我们使用 MD5 算法对密码进行哈希，并最终转换为 Base64 字符串。在验证密码时，我们只需要再次哈希输入的密码，然后与数据库中的密码哈希进行比较即可。\nInfo\r为什么我们通常会将密码转为 Base64 字符串再进行存储，而不是直接存为比如 BLOB 呢？这是因为 Base64 字符串是可读的，方便我们在数据库中查看。不仅如此，字符串的索引的效率也比 BLOB 更高。\n在后面的方法中，我们还会看到一些哈希后的密码本身就是可读字符串的方法。所以通常我们会将密码哈希转为字符串进行存储。\n此时我们保存的密码可能形如：\nISMvKXpXpadDiUoOSoAfww==\n现在这个密码看起来显然比明文要安全多了。但很可惜，在黑客看来，这样的密码恐怕并没有安全太多，因为有一招叫做彩虹表攻击。简单来说，黑客可以提前生成一张巨大的彩虹表，里面包含了常见密码的哈希值。然后黑客只需要将数据库中的哈希值与彩虹表中的哈希值进行比对，就可以很快地找到密码。\n比如上面的密码，对应的明文是 admin。黑客只需要在彩虹表中找到对应的哈希值，就可以轻松破解密码了。可不要小看这个彩虹表，它通常包含巨量的常见密码，甚至是所有可能的密码组合。所以，除非你的密码比较复杂（比如包含大小写、数字及符号），否则可能就会被彩虹表轻易破解。\n不仅如此，MD5 和 SHA1 算法本身也是不安全的。它们已经被证明是可以被碰撞的。所谓碰撞，就是两个不同的输入可以生成相同的哈希值。这样的话，黑客就可以通过碰撞来破解密码了。以上述例子来说，虽然黑客可能无法通过彩虹表得知我们的明文是 admin，但是他通过计算发现，qwerty 同样可以生成相同的哈希值，那么他就可以用 qwerty 来登录了。毕竟服务器端的校验只会比对哈希值，而不会比对明文。\n使用 SHA256 加盐 \u0026para; 那么，我们只好进一步升级我们的算法了。这次我们使用能够防止碰撞的 SHA256（它是 SHA-2 系列中的一种，其他常见的还有 SHA-384、SHA-512 等）算法，并且加入一个随机的盐值：\n1 2 3 4 5 6 7 class User { public int Id { get; set; } // 自增主键 public string Username { get; set; } public string PasswordHash { get; set; } // 密码哈希 public string Salt { get; set; } // 盐值 } 然后，我们修改一下 PasswordHelper 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class PasswordHelper { public static string HashPassword(string password, byte[] salt) { var passwordBytes = Encoding.UTF8.GetBytes(password); var combinedBytes = new byte[passwordBytes.Length + salt.Length]; Array.Copy(passwordBytes, 0, combinedBytes, 0, passwordBytes.Length); Array.Copy(salt, 0, combinedBytes, passwordBytes.Length, salt.Length); var hash = SHA256.HashData(combinedBytes); return Convert.ToBase64String(hash); } public static bool VerifyPassword(string password, string passwordHash, byte[] salt) { return HashPassword(password, salt) == passwordHash; } public byte[] GenerateSalt() { return RandomNumberGenerator.GetBytes(16); // 一般 16 字节（256 位）的盐值即可 } } Tip\r在较新版本的 .NET 中，我们可以使用很多便利的静态方法，比如 SHA256.HashData，RandomNumberGenerator.GetBytes 等，而不需要我们先创建实例。\n在以前，大家可能会见过使用 RNGCryptoServiceProvider 来生成随机数的方法。但是该方法现在已经过时。\n在这个方法中，我们将密码和盐值合并后再进行哈希。这样，即使两个用户的密码相同，由于盐值不同，最终的哈希值也会不同。这样就避免了碰撞的问题。\n此外，盐值也是需要存储在数据库中的。这样，在进行密码校验时，会根据用户的 Id 或 Username 从数据库中取出盐值及加盐哈希后的密码，然后再将用户输入的密码使用相同的盐值进行哈希，最后与数据库中的密码进行比对，从而判断密码是否正确。\n这样的密码存储方式，即使黑客拿到了数据库，也无法直接破解密码。因为彩虹表攻击现在已经不再有效，毕竟每个用户都有不同的盐值。\n使用 PBKDF2 \u0026para; SHA256 加盐的方式已经相当安全了，但是我们还可以进一步提升安全性。因为黑客虽然无法使用彩虹表，但仍然可以尝试暴力破解密码。简单来说，黑客可以尝试使用各种密码组合，然后通过哈希后的密码与数据库中的密码进行比对，从而破解密码。\n所以，为了提高密码被暴力破解的难度，之后我们要考虑的方案基本上就是围绕着提高计算的速度来展开。首先，我们可以考虑使用 PBKDF2 算法。这个算法在很多编程语言的标准库中均有提供。在 C# 中，我们可以使用 Rfc2898DeriveBytes 类来实现。我们只需要稍加修改我们的 PasswordHelper 类即可：\n1 2 3 4 5 6 7 8 9 10 class PasswordHelper { public static string HashPassword(string password, byte[] salt) { using var pbkdf2 = new Rfc2898DeriveBytes(password, salt, 10000, HashAlgorithmName.SHA256); // 迭代 10000 次 return Convert.ToBase64String(pbkdf2.GetBytes(32)); // 32 字节（256 位）的哈希值 } // 其他方法不变 } Info\rRfc2898 是 PBKDF2 的一个实现，所以这里可以说是一回事，只是名字不同。另外，Rfc2898DeriveBytes 的构造函数中，我们需要给定使用的哈希算法，否则不包含这一传参的构造函数会提示已过时。\r在这个方法中，我们使用 Rfc2898DeriveBytes 类来进行密码哈希。我们可以指定迭代次数，这样就可以提高计算的速度。一般来说，迭代次数越多，计算的速度就越慢，黑客破解密码的难度就越大。但是，迭代次数也不能太多，否则会影响用户登录的速度。一般来说，10000 次迭代是一个比较合适的值。\n有了这一算法的加持，现在黑客想要暴力破解，需要付出的代价就会大大增加。\n使用 BCrypt 和 Argon2 \u0026para; 但可惜的是，道高一尺，魔高一丈。PBKDF2 算法虽然提高了黑客暴力破解密码的难度，但是仍然有一些问题。比如，黑客可以使用 GPU 或 FPGA 来加速计算，从而提高暴力破解的速度。所以，我们还有更加重量级的选手：BCrypt 及 Argon2。\n我们先来看 BCrypt。在 C# 中，我们可以使用 BCrypt.Net-Next 库来实现 BCrypt 算法。我们只需要稍加修改我们的 PasswordHelper 类即可：\n1 2 3 4 5 6 7 8 9 10 11 12 class PasswordHelper { public static string HashPassword(string password) { return BCrypt.Net.BCrypt.HashPassword(password, 12); // 12 为工作因子 } public static bool VerifyPassword(string password, string passwordHash) { return BCrypt.Net.BCrypt.Verify(password, passwordHash); } } 并且我们的 User 类也可以去掉 Salt 属性了。这是为什么呢？因为 BCrypt 算法本身就包含了盐值，相当于替我们代劳了。这样，我们就不需要再自己生成盐值，也不需要专门去存储盐值了。\n我们看一个 BCrypt 哈希后的密码：\n$2a$11$lraBT1/lH3RiFXjQbywREutDElnBFaolPOEsDAvo1sjK2iRjwCAUi\n这段文本中，$2a$ 表示使用的是 BCrypt 算法，11 表示工作因子，而后面的内容则是由盐值和哈希后的密码组成。也就是说，这段文本中包含了全部用来验证密码的信息，我们只需要将其存储在数据库中即可。\nInfo\r工作因子是用来控制计算的速度的，它是 $2$ 的幂运算。比如，上面的密码就对应了 $2^{11}=2048$ 次计算。工作因子越大，计算的速度就越慢，黑客破解密码的难度就越大。通常 $10$ 到 $12$ 是一个比较合适的范围。\r但黑客依旧不甘心，还是打算借助其强大的硬件来尝试破解。这样，我们就要请出我们的杀手锏：Argon2 算法了。\n与 BCrypt 一样，Argon2 同样没有 .NET 标准库的实现。我们可以选择一些第三方的库，比如 Konscious.Security.Cryptography。\n这里，我们不演示实际在 C# 中该如何使用 Argon2 算法，因为它与 BCrypt 在开发体验及数据模型和表的设计上是类似的。但是，Argon2 算法在安全性上要比 BCrypt 更胜一筹。它引入了更多防止黑客暴力破解的机制，比如内存硬化、并行计算等。它可以轻易调整破解的时间、内存成本以及并行度。\n另外，Argon2 还提供了三种变体：Argon2d、Argon2i 和 Argon2id。其中，Argon2d 适用于对抗时间攻击，Argon2i 适用于对抗侧信道攻击，而 Argon2id 则是两者的结合。具体来说：\nArgon2d 更注重防止 GPU 并行计算的攻击。 Argon2i 更注重抗侧信道攻击。 Argon2id 是综合了这两种特性，适合一般用途。 相信有了这么“变态”的密码哈希算法，至少现阶段的黑客是彻底束手无策了。\n总结 \u0026para; 在这篇文章中，我们从最不安全的明文存储密码开始，逐步讲解了为什么我们需要对密码进行加盐哈希。我们看到了明文存储密码的危险性，哈希后的密码可能被彩虹表攻击的问题。以及老旧的哈希算法可能存在的被碰撞的问题。然后，我们介绍了 SHA256 加盐、PBKDF2、BCrypt 和 Argon2 等算法，以及它们的优缺点。\n在实际开发中，我们应当根据自己的需求和安全性要求来选择适合的密码哈希算法。对于一般的小项目来说，SHA256 加盐已经足够安全了，而且它对于客户端及服务端开销的要求也很低。但是，如果我们对安全性要求很高，那么 BCrypt 或 Argon2 就是不二之选了。\n","date":"2025-01-23T00:00:00Z","image":"https://s2.loli.net/2025/01/23/oNjelMu2p8TmiPw.jpg","permalink":"https://blog.coldwind.top/posts/why-password-hash-with-salt/","title":"为什么用户密码需要加盐哈希后再存储？"},{"content":"这次我们来探讨一个 WPF 中的简单而又不简单的布局问题：如何实现下图中的效果？\n为什么说这个问题简单而又不简单呢？是因为单纯只是实现这个效果的话，我们完全可以使用 Grid 控件来实现。甚至如果完全不在乎优雅的话，我们还可以用 Canvas 来实现（当然这几乎在任何情况下都是不推荐的）。但是，实际这样干过的开发者相信都很清楚，使用 Grid 的实现方式几乎可以说是毫无灵活性的。很快就会被后续的界面微调的需求整得焦头烂额。\n那么我们今天就来看一看，这样的需求通常有哪些做法吧。希望这篇文章中提到的某些方式能够帮助到你。\n最传统的方式：Grid \u0026para; 在介绍后面的更好的方式之前，我们有必要先来看一看最传统的方式：使用 Grid 控件。这样才能更好地分析这种方式的局限性，以及思考改进的方向。\n这样的方式相信所有具备基本 WPF 基础的开发者都相当熟悉：\n在 XAML 中定义一个 Grid 控件 在 Grid 中定义多个 RowDefinition 和 ColumnDefinition 在 Grid 中定义多个控件，并通过 Grid.Row 和 Grid.Column 来指定控件的位置 （可选）通过 Grid.RowSpan 和 Grid.ColumnSpan 来指定控件的跨行和跨列 好，然后我们就开始写 XAML 吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;Auto\u0026#34; /\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;Auto\u0026#34; /\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;Auto\u0026#34; /\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;Auto\u0026#34; /\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition Width=\u0026#34;Auto\u0026#34; /\u0026gt; \u0026lt;ColumnDefinition Width=\u0026#34;Auto\u0026#34; /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Label Grid.Row=\u0026#34;0\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Content=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;TextBox Grid.Row=\u0026#34;0\u0026#34; Grid.Column=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;Label Grid.Row=\u0026#34;1\u0026#34; Grid.Column=\u0026#34;0\u0026#34; Content=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;TextBox Grid.Row=\u0026#34;1\u0026#34; Grid.Column=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/Grid\u0026gt; 好的，马上痛苦面具就戴上了：为每个控件写 Grid.Row 和 Grid.Column，简直就是顶级折磨。如果你搞了十几行，结果被告知需要删掉前面某一行，或者在前面添加一行，那就更是欲哭无泪了。\nTip\r可能会有聪明的同学想到一些简化这一步骤的方式，比如使用 Style 来统一指定上面的 TextBox 控件的 Grid.Column，并省略 Label 的 Grid.Column=\u0026quot;0\u0026quot;。但这样依旧存在相当多的局限性，毕竟它最怕的就是例外情况了。\r所以，我们显然是不能满足于使用这样的方式的。那究竟有什么更好的方式呢？\n外层使用 UniformGrid \u0026para; 说起“自动化布局”，相信很多人在使用 Grid 时都垂涎过 UniformGrid 的功能，因为它可以让所有子控件依次填充到每个单元格中。所以，我们或许可以借助它的这一效果。比如我们想要一个两列的网格，可以：\n1 2 3 4 5 6 \u0026lt;UniformGrid Columns=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;Label Content=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;TextBox /\u0026gt; \u0026lt;Label Content=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;TextBox /\u0026gt; \u0026lt;!-- ... --\u0026gt; 但这样的局限性在于，所有子控件的大小（或者它们所处的单元格）都是完全等大的。这可能会失去灵活性，并且看起来有些呆板。那么我们还可以部分借助 UniformGrid 的功能，比如下面这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;UniformGrid Columns=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;UniformGrid.Resources\u0026gt; \u0026lt;Style TargetType=\u0026#34;StackPanel\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Orientation\u0026#34; Value=\u0026#34;Horizontal\u0026#34; /\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;Style TargetType=\u0026#34;Label\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Width\u0026#34; Value=\u0026#34;50\u0026#34; /\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/UniformGrid.Resources\u0026gt; \u0026lt;StackPanel\u0026gt; \u0026lt;Label Content=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;TextBox /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;StackPanel\u0026gt; \u0026lt;Label Content=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;TextBox /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/UniformGrid\u0026gt; 这里我们将每一行的内容放在了一个 StackPanel 中，从而让 Label 和 TextBox 出现在同一行（或者说 UniformGrid 的同一个单元格中）。这样我们就不需要再为每个控件指定 Grid.Row 和 Grid.Column 了。\n为了更加简化代码，我们还声明了两个 Style，分别用于设置 StackPanel 的 Orientation 和 Label 的 Width。这样我们就可以在 StackPanel 中直接放置 Label 和 TextBox，而不需要再为 Label 设置宽度了。\n但是这样做有一个明显的局限性：行高是一致的。如果我们需要不同行的高度不一致，那么这种方式就无法满足需求了。\n外层使用 StackPanel \u0026para; 为了突破上一个方式的局限性，我们可以考虑使用 StackPanel 来替代 UniformGrid。这样我们就可以为每一行的 StackPanel 设置不同的高度了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;StackPanel Orientation=\u0026#34;Vertical\u0026#34;\u0026gt; \u0026lt;StackPanel.Resources\u0026gt; \u0026lt;!-- Styles --\u0026gt; \u0026lt;/StackPanel.Resources\u0026gt; \u0026lt;StackPanel Height=\u0026#34;40\u0026#34;\u0026gt; \u0026lt;Label Content=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;TextBox /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;StackPanel Height=\u0026#34;50\u0026#34;\u0026gt; \u0026lt;Label Content=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;TextBox /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/StackPanel\u0026gt; 但很快，我们又会被别的问题所折磨：如何高效地设置行间距？\n而且可能还有另外一个小折磨：因为内外都使用了 StackPanel，所以写的 Style 可能会被它们共同使用。\nInfo\r针对这一问题，可能有同学会将内部的 StackPanel 替换为 WrapPanel，但这样并不是一个好主意，因为 WrapPanel 会让每一行的控件都尽可能地靠左对齐，并且在宽度不够时会自动换行！或许现在看着还好，但调整了窗口或父控件的尺寸，甚至修改了分辨率及缩放后，都有可能让你的界面变得一团糟。\r此时，我们可以请个“外援”。其实在 Win UI 3、Avalonia UI 等框架中，StackPanel 天生就比 WPF 多了一个属性：Spacing。这个属性可以让我们很方便地设置行间距。但是在 WPF 中，我们就没有这么幸运了。不过，我们可以借助自定义控件来实现这一功能。\n代码也不用我们自己写，网上可以找到一些开源实现。比如这里我贴两个供大家参考：\nKinnara/ModernWpf - SimpleStackPanel OrgEleCho/WpfSuite - StackPanel 假如我们搬运到了 local 命名空间下，那么我们就可以这样使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;local:StackPanel Spacing=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;local:StackPanel.Resources\u0026gt; \u0026lt;Style TargetType=\u0026#34;StackPanel\u0026#34;\u0026gt; \u0026lt;Setter Property=\u0026#34;Orientation\u0026#34; Value=\u0026#34;Horizontal\u0026#34; /\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/local:StackPanel.Resources\u0026gt; \u0026lt;StackPanel\u0026gt; \u0026lt;Label Content=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;TextBox /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;StackPanel\u0026gt; \u0026lt;Label Content=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;TextBox /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/local:StackPanel\u0026gt; 这样看起来就方便多了。此外，我们还有一些小技巧，来进一步提高布局的效率：\n为 Label 设置一个固定的宽度，这样可以让所有的 Label 对齐 为 Label 设置 VerticalAlignment 或 VerticalContentAlignment 为 Center，这样可以让 Label 和 TextBox 垂直居中对齐 为 TextBox 等控件（还比如 CheckBox、ComboBox 等）设置固定的宽度，这样可以让所有的 TextBox 对齐 使用更高级的 Grid \u0026para; 上面的方式其实已经相当灵活了，尤其是对于可能需要增删、调换顺序之类的情形。但是可能仍然会觉得不够爽，因为里面多出了一层 StackPanel，这写起来就还是会觉得不太爽。\n所以，有没有办法让 Grid 更加智能一点，比如可以像是 WrapPanel 或者 UniformGrid 那样，自动填充控件呢？\n答案当然是有的。这里给大家推荐一个 NuGet 包：WpfAutoGrid。这个 AutoGrid 就正是我们梦寐以求的控件。\nInfo\rNuGet 上有好多个叫这个名字的包。这里我贴一个自己试过的：WpfAutoGrid.Core\r它的使用也非常简单：\n1 2 3 4 5 6 7 \u0026lt;local:AutoGrid Columns=\u0026#34;100,150\u0026#34; RowCount=\u0026#34;8\u0026#34; RowHeight=\u0026#34;30\u0026#34;\u0026gt; \u0026lt;Label Content=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;TextBox /\u0026gt; \u0026lt;Label Content=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;TextBox /\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/local:AutoGrid\u0026gt; 这样我们连内部的 StackPanel 都不需要了，直接将 Label 和 TextBox 放在 AutoGrid 中即可。此外，它提供了很多实用的属性，比如上面实用的 Columns、RowCount、RowHeight，还有 ColumnSpacing、RowSpacing 等。不仅如此，AutoGrid 还能正确响应子控件 ColumnSpan 等属性，可以让我们更加灵活地布局控件。\n除此之外，这里我再贴一个我自己写的 GridAssist。它是一个附加属性，可以直接用于原生的 Grid 控件。使用这个附加属性，就能够自动为子控件添加 Grid.Row 和 Grid.Column 属性。\nBYJRK/GridAssist\n使用方式也非常简单：\n1 2 3 4 5 6 7 \u0026lt;Grid local:GridAssist.AutoRowColumn=\u0026#34;_,2\u0026#34;\u0026gt; \u0026lt;Label Content=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;TextBox /\u0026gt; \u0026lt;Label Content=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;TextBox /\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/Grid\u0026gt; 这个附加属性的 AutoRowColumn 填写的 _,2 意思是，行数自动增加，列数固定为 2（还可以写 _,2,Auto，从而将列宽设置为 Auto）。这样我们就不需要为每个控件指定 Grid.Row 和 Grid.Column 了。然后，我们只需要将子控件按照从上到下，从左到右的顺序放置即可，不需要再引入一层 StackPanel 了。此外，它也是可以正确响应 Grid.ColumnSpan 的。\n总结 \u0026para; 在 WPF 中，布局是一个非常重要的问题。而对于多行多列的控件布局，我们可以使用 Grid、UniformGrid、StackPanel、AutoGrid 等控件或者附加属性来实现。每一种方式都有它的优势和局限性，我们可以根据实际情况来选择最适合的方式。\n另外，对于上面提到的几种自定义控件或附加属性，我们完全可以直接将代码复制到自己的项目中，然后根据实际需求进行修改。这样可以更好地适应自己的项目，也可以更好地理解这些控件或属性的实现原理，还可以省去引入第三方库的麻烦。\n","date":"2024-12-26T00:00:00Z","image":"https://s2.loli.net/2024/12/26/kgGyXcYIlnMNpSr.jpg","permalink":"https://blog.coldwind.top/posts/grid-of-controls/","title":"如何在 WPF 中高效布局多行多列的控件"},{"content":"本篇文章对应的教学视频链接：WPF中值转换器（ValueConverter）的一些实用技巧\n在 WPF 中，值转换器（ValueConverter）是一个非常重要的概念。它可以帮助我们在绑定数据时，将数据转换成我们需要的格式。在这篇文章中，我们将介绍一些值转换器的实用技巧。\n使用 WPF 内置的值转换器 \u0026para; WPF 内置了几个常用的值转换器，我们可以直接使用。例如，我们可以使用 BooleanToVisibilityConverter 将布尔值转换成 Visibility 枚举值。\n1 2 3 4 5 6 7 8 \u0026lt;Window.Resources\u0026gt; \u0026lt;BooleanToVisibilityConverter x:Key=\u0026#34;BooleanToVisibilityConverter\u0026#34;/\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;StackPanel\u0026gt; \u0026lt;CheckBox x:Name=\u0026#34;checkBox\u0026#34; Content=\u0026#34;Show Text\u0026#34; IsChecked=\u0026#34;True\u0026#34;/\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Hello, World!\u0026#34; Visibility=\u0026#34;{Binding ElementName=checkBox, Path=IsChecked, Converter={StaticResource BooleanToVisibilityConverter}}\u0026#34;/\u0026gt; \u0026lt;/StackPanel\u0026gt; 遗憾的是，WPF 内置的值转换器并不是很多，基本上我们能直接用上的就是上面提到的这个 BooleanToVisibilityConverter。其他虽然有一些照理说用得上的值转换器，但它们很多都是 internal 的，我们无法直接使用。即便如此，通过阅读它们的源代码，我们仍然可以学习一下它们的实现方式。比如：\nEnumBoolConverter BooleanReverseConverter 将值转换器声明为单例 \u0026para; 使用值转换器有些是否会让人觉得繁琐，因为通常这意味着我们需要在某个控件的 Resources 中声明一个值转换器，并在需要的地方通过 StaticResource 来引用它。但实际上，我们可以将值转换器声明为单例，这样就可以在任何地方直接使用它。比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class BooleanToVisibilityConverter : IValueConverter { // 单例模式 public static BooleanToVisibilityConverter Instance { get; } = new(); public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { // ... } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { // ... } } 然后我们就可以在 XAML 中借助 x:Static 来直接使用这个单例：\n1 2 3 4 \u0026lt;StackPanel\u0026gt; \u0026lt;CheckBox x:Name=\u0026#34;checkBox\u0026#34; Content=\u0026#34;Show Text\u0026#34; IsChecked=\u0026#34;True\u0026#34;/\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Hello, World!\u0026#34; Visibility=\u0026#34;{Binding ElementName=checkBox, Path=IsChecked, Converter={x:Static local:BooleanToVisibilityConverter.Instance}}\u0026#34;/\u0026gt; \u0026lt;/StackPanel\u0026gt; Warning\r这样确实可以一定程度上简化我们的代码，但也要注意，这样做可能会导致值转换器的状态被共享，从而引发一些问题。所以在使用这种方式时，一定要确保值转换器是无状态的。\r将值转换器声明在 App.xaml 中 \u0026para; 如果我们有一些相当通用且无状态的值转换器，就比如 BooleanToVisibilityConverter、BoolReverseConverter、NotNullConverter 等，我们可以将它们声明在 App.xaml 中，这样就可以在整个应用程序中直接使用这些值转换器，而不需要在每个用到它们的 Window、UserControl 等地方都进行声明。\n1 2 3 4 5 6 7 \u0026lt;Application ...\u0026gt; \u0026lt;Application.Resources\u0026gt; \u0026lt;BooleanToVisibilityConverter x:Key=\u0026#34;BooleanToVisibilityConverter\u0026#34;/\u0026gt; \u0026lt;BoolReverseConverter x:Key=\u0026#34;BoolReverseConverter\u0026#34;/\u0026gt; \u0026lt;NotNullConverter x:Key=\u0026#34;NotNullConverter\u0026#34;/\u0026gt; \u0026lt;/Application.Resources\u0026gt; \u0026lt;/Application\u0026gt; 如果觉得这样的方式会“污染”App.xaml，我们也可以新建一个 ResourceDictionary，并将这些值转换器声明在这个 ResourceDictionary 中，然后在 App.xaml 中引用这个 ResourceDictionary。例如，我们可以新建一个 CommonConverters.xaml：\n1 2 3 4 5 \u0026lt;ResourceDictionary ...\u0026gt; \u0026lt;BooleanToVisibilityConverter x:Key=\u0026#34;BooleanToVisibilityConverter\u0026#34;/\u0026gt; \u0026lt;BoolReverseConverter x:Key=\u0026#34;BoolReverseConverter\u0026#34;/\u0026gt; \u0026lt;NotNullConverter x:Key=\u0026#34;NotNullConverter\u0026#34;/\u0026gt; \u0026lt;/ResourceDictionary\u0026gt; 然后在 App.xaml 中引用这个 ResourceDictionary：\n1 2 3 4 5 6 7 8 9 \u0026lt;Application ...\u0026gt; \u0026lt;Application.Resources\u0026gt; \u0026lt;ResourceDictionary\u0026gt; \u0026lt;ResourceDictionary.MergedDictionaries\u0026gt; \u0026lt;ResourceDictionary Source=\u0026#34;CommonConverters.xaml\u0026#34;/\u0026gt; \u0026lt;/ResourceDictionary.MergedDictionaries\u0026gt; \u0026lt;/ResourceDictionary\u0026gt; \u0026lt;/Application.Resources\u0026gt; \u0026lt;/Application\u0026gt; 使用 MarkupExtension 简化值转换器的使用 \u0026para; Markup 语法也就是我们经常在 XAML 中看到的“花括号”语法，例如：\n{Binding ...} {StaticResource ...} {x:Static ...} 只要我们让值转换器继承 MarkupExtension，我们就可以在 XAML 中直接使用 Markup 语法来引用这个值转换器。比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class BooleanToVisibilityConverter : MarkupExtension, IValueConverter { public bool IsReversed { get; set; } public bool UseHidden { get; set; } public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { if (value is bool b) { b = IsReversed ? !b : b; return b ? Visibility.Visible : (UseHidden ? Visibility.Hidden : Visibility.Collapsed); } } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { if (value is Visibility visibility) { return visibility == Visibility.Visible; } } public override object ProvideValue(IServiceProvider serviceProvider) { return this; } } 上面是一个“高级版”的 BooleanToVisibilityConverter，它支持 IsReversed 和 UseHidden 两个属性，也就为这一值转换器提供了定制性。我们可以在 XAML 中这样使用它：\n1 2 3 4 \u0026lt;StackPanel\u0026gt; \u0026lt;CheckBox x:Name=\u0026#34;checkBox\u0026#34; Content=\u0026#34;Show Text\u0026#34; IsChecked=\u0026#34;True\u0026#34;/\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Hello, World!\u0026#34; Visibility=\u0026#34;{Binding ElementName=checkBox, Path=IsChecked, Converter={local:BooleanToVisibilityConverter IsReversed=True, UseHidden=True}}\u0026#34;/\u0026gt; \u0026lt;/StackPanel\u0026gt; 这一技巧尤其适用于某个定制功能强大，且使用频率较高的值转换器。但也要注意，这样声明就会导致值转换器每次都会实例化一个新的出来。如果一个值转换器是无状态的，那么我们最好将其声明为单例，或者将其声明在 App.xaml 中，从而避免重复实例化。\n如果还觉得不过瘾，我们可以为值转换器写一个抽象基类，从而进一步简化值转换器的实现。比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract class BaseValueConverter : MarkupExtension, IValueConverter { public override object ProvideValue(IServiceProvider serviceProvider) { return this; } public abstract object Convert(object value, Type targetType, object parameter, CultureInfo culture); public virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { return Binding.DoNothing; } } 另外还有一种版本，就是希望基类还顺便提供单例模式，那么我们可以这样：\n1 2 3 4 5 6 7 public abstract class BaseValueConverter\u0026lt;T\u0026gt; : MarkupExtension, IValueConverter where T : class, new() { public static T Instance { get; } = new(); // ... } 然后我们就可以使用它了。比如说我们希望实现一个单向的值转换器，将字符串转换成大写，可以这样：\n1 2 3 4 5 6 7 8 9 10 11 12 public class StringToUpperConverter : BaseValueConverter\u0026lt;StringToUpperConverter\u0026gt; { public override object Convert(object value, Type targetType, object parameter, CultureInfo culture) { if (value is string s) { return s.ToUpper(); } return Binding.DoNothing; } } 是不是瞬间变得简单了很多呢？\n返回 DoNothing 与 UnsetValue \u0026para; 在 WPF 中，有两个特殊的返回类型，分别是 Binding.DoNothing 和 DependencyProperty.UnsetValue。在某些情况下，让值转换器的方法返回这两个值是非常有用的。\n这两个都表示“不做任何事情”，但它们的使用场景是不同的。具体来说，Binding.DoNothing 单纯意味着“不做任何事情”，不去通知任何绑定源或目标，也不会更新界面；而 DependencyProperty.UnsetValue 则暗示绑定是失败的，或者值是无效的。此时，它会触发 Binding 的 FallbackValue，也就是俗称的“缺省值”。\n比如我们有一个可以让用户输入文件路径的文本框，并且我们会让另一个 TextBlock 展示这个文件的名称。但是如果用户输入的路径是无效的，我们就不希望展示这个文件的名称，而是展示一个缺省值，这时我们就可以使用 DependencyProperty.UnsetValue：\n1 2 3 4 5 6 7 8 9 10 11 public class FilePathToFileNameConverter : IValueConverter { public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { if (value is string path \u0026amp;\u0026amp;n File.Exists(path)) { return Path.GetFileName(path); } return DependencyProperty.UnsetValue; } } 然后我们可以在 XAML 中这样使用：\n1 2 3 4 \u0026lt;StackPanel\u0026gt; \u0026lt;TextBox x:Name=\u0026#34;textBox\u0026#34; Text=\u0026#34;C:\\Users\\Public\\Documents\\file.txt\u0026#34;/\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding ElementName=textBox, Path=Text, Converter={local:FilePathToFileNameConverter}, FallbackValue=\u0026#39;Invalid File Path\u0026#39;}\u0026#34;/\u0026gt; \u0026lt;/StackPanel\u0026gt; 这样，当用户输入的文件路径无效时，TextBlock 就会展示“Invalid File Path”。\n类似地，如果我们希望用户在输入无效的文件路径时，不做任何事情（比如保留上次有效的文件名城），我们就可以返回 Binding.DoNothing。然后就可以实现相应的效果了。\n这两个特殊的返回值看似不起眼，但是如果上述功能让我们在 ViewModel 中去实现，就会变得非常繁琐。所以在这种情况下，值转换器就显得非常有用了。\n借助 CultureInfo 实现多语言支持 \u0026para; 值转换器中的两个方法都有一个 CultureInfo 类型的参数，我们可以利用这个参数来实现多语言支持。比如我们有一个值转换器，将数字转换成各国语言的数字。此时我们就可以在值转换器中根据 CultureInfo 所包含的地区码来选择合适的语言。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class NumberToLocalizedNumberConverter : IValueConverter { public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { if (value is int number) { switch (culture.TwoLetterISOLanguageName) { case \u0026#34;zh\u0026#34;: return number switch { 0 =\u0026gt; \u0026#34;零\u0026#34;, 1 =\u0026gt; \u0026#34;一\u0026#34;, 2 =\u0026gt; \u0026#34;二\u0026#34;, 3 =\u0026gt; \u0026#34;三\u0026#34;, 4 =\u0026gt; \u0026#34;四\u0026#34;, 5 =\u0026gt; \u0026#34;五\u0026#34; }; case \u0026#34;en\u0026#34;: return number switch { 0 =\u0026gt; \u0026#34;Zero\u0026#34;, 1 =\u0026gt; \u0026#34;One\u0026#34;, 2 =\u0026gt; \u0026#34;Two\u0026#34;, 3 =\u0026gt; \u0026#34;Three\u0026#34;, 4 =\u0026gt; \u0026#34;Four\u0026#34;, 5 =\u0026gt; \u0026#34;Five\u0026#34; }; default: return number.ToString(); } } return Binding.DoNothing; } } 然后我们可以在 XAML 中这样使用：\n1 2 3 \u0026lt;StackPanel\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Number, Converter={local:NumberToLocalizedNumberConverter}, ConverterCulture=zh-CN}\u0026#34;/\u0026gt; \u0026lt;/StackPanel\u0026gt; 或者我们也可以在程序中动态地设置 CultureInfo：\n1 2 3 4 var culture = new CultureInfo(\u0026#34;zh-CN\u0026#34;); Thread.CurrentThread.CurrentCulture = culture; Thread.CurrentThread.CurrentUICulture = culture; 但是这样还不够，因为值转换器的这一入参是从控件的 Language 属性中继承而来的。所以我们还需要修改全局的 Language 属性。例如，我们想在一个 UserControl 中使用中文，可以这样：\n1 2 3 4 5 6 \u0026lt;UserControl Language=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;!-- 也可以这样写 --\u0026gt; \u0026lt;UserControl.Language\u0026gt; \u0026lt;XmlLanguage\u0026gt;zh-CN\u0026lt;/XmlLanguage\u0026gt; \u0026lt;/UserControl.Language\u0026gt; \u0026lt;/UserControl\u0026gt; 或者，我们还可以用 OverrideMetadata 的方式来修改全局的 Language 属性：\n1 2 3 4 5 6 7 FrameworkElement.LanguageProperty .OverrideMetadata( typeof(FrameworkElement), new FrameworkPropertyMetadata( XmlLanguage.GetLanguage(CultureInfo.CurrentCulture.IetfLanguageTag) ) ); 这样就可以让值转换器获取到当前的 CultureInfo，从而实现多语言支持。\n仿照 Avalonia UI 实现一个 FuncValueConverter \u0026para; Avalonia UI 中有一个有趣的 FuncValueConverter，它允许我们直接在代码后台简单地声明一个值转换器，而不需要额外写一个类。它地源代码可以在 GitHub 上看到。我们可以仿照这个实现一个类似的值转换器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public sealed class FuncValueConverter\u0026lt;TIn, TOut\u0026gt; : IValueConverter { private readonly Func\u0026lt;TIn, TOut\u0026gt; _convert; public FuncValueConverter(Func\u0026lt;TIn, TOut\u0026gt; convert) { _convert = convert; } public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { if (value is TIn t) { return _convert(t); } return Binding.DoNothing; } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { return Binding.DoNothing; } } 对于 Convert 方法的实现，这里还有一种更好的方式。我们都知道，在 XAML 书写的很多资源，WPF 都会在底层帮我们进行合适的类型转换。比如我们将 \u0026quot;1\u0026quot; 字符串赋值给一个 int 类型的属性，WPF 会自动将其转换成 1；我们将 \u0026quot;Visible\u0026quot; 字符串赋值给一个 Visibility 枚举类型的属性，WPF 也会进行相应的转换。如果我们不提供这个功能，那么我们写的这个 FuncValueConverter 就会变得不够灵活。因此，我们可以借助 .NET 原生的 TypeDescriptor 类来实现这个功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { if (value is not TIn t) { if (value is null) { return default(TOut); } if (TypeDescriptor.GetConverter(typeof(TIn)).CanConvertFrom(value.GetType())) { t = (TIn)TypeDescriptor.GetConverter(typeof(TIn)).ConvertFrom(value); } else { return Binding.DoNothing; } } return _convert(t); } 这样我们就可以声明并使用了。我们需要将它声明为静态属性：\n1 2 3 4 public class MainViewModel : ViewModelBase { public static FuncValueConverter\u0026lt;string, int\u0026gt; StringToIntConverter { get; } = new(s =\u0026gt; int.Parse(s)); } 然后我们就可以在 XAML 中这样使用：\n1 2 3 4 \u0026lt;StackPanel\u0026gt; \u0026lt;TextBox x:Name=\u0026#34;textBox\u0026#34; Text=\u0026#34;123\u0026#34;/\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding ElementName=textBox, Path=Text, Converter={x:Static local:MainViewModel.StringToIntConverter}}\u0026#34;/\u0026gt; \u0026lt;/StackPanel\u0026gt; 这样，我们就能够轻易地在代码后台声明一个值转换器了。\n其他第三方库 \u0026para; 除了上面提到的这些方法，我们还可以使用一些第三方库来简化值转换器及绑定的使用。比如：\nValueConverters.NET CalcBinding CompiledBindings 这些库有的提供了丰富的内置值转换器，包括组合多种值转换器的功能（例如先将字符串根据 IsNullOrEmpty 转为 bool 类型，再转为 Visibility 类型），有的提供了更加强大的绑定功能，例如可以调用函数，进行数学运算等等。大家有兴趣的话可以去了解一下。\n总结 \u0026para; 值转换器是 WPF 中非常重要的一个概念，它可以帮助我们将数据转换成我们需要的格式。在这篇文章中，我们介绍了一些值转换器的实用技巧。希望这些技巧能够帮助大家更好地使用值转换器。\n只有充分发挥 WPF 中各个功能的优势，我们才能更好地提高我们的开发效率，实现更加复杂的功能。希望大家能够在实际的开发中多多尝试，多多实践。\n","date":"2024-12-18T00:00:00Z","image":"https://s2.loli.net/2024/12/18/dRbx2KJsHOmaPG7.webp","permalink":"https://blog.coldwind.top/posts/valueconverter-tips-and-tricks/","title":"WPF 值转换器（ValueConverter）的一些实用技巧"},{"content":"拷贝文件夹听起来是一个非常简单的任务，但是在 C# 中实现起来却并不是那么容易，因为 .NET 并没有提供内置的方法，所以通常我们只能自己来实现。\n本文提供了三种拷贝文件夹的方式供大家参考。\n方法一：使用递归 \u0026para; 使用递归是一个非常直观的方法，同时也是 Microsoft Learn 给出的示例。其原版的代码有些冗余和不必要的内存开销，所以这里贴一个相对简练且高效的版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static void CopyDirectory(string sourceFolderPath, string targetFolderPath) { Directory.CreateDirectory(targetFolderPath); foreach (string filePath in Directory.GetFiles(sourceFolderPath)) { string fileName = Path.GetFileName(filePath); string destinationPath = Path.Combine(targetFolderPath, fileName); File.Copy(filePath, destinationPath, true); } foreach (string directoryPath in Directory.GetDirectories(sourceFolderPath)) { string directoryName = Path.GetFileName(directoryPath); string destinationPath = Path.Combine(targetFolderPath, directoryName); CopyDirectory(directoryPath, destinationPath); } } 简单来说，这个方法会递归地拷贝源文件夹下的所有文件和子文件夹到目标文件夹中。对于子文件夹，会递归调用该方法进行拷贝。\nTip\rDirectory.CreateDirectory 是一个相当灵活的方法。如果目标文件夹不存在，它会自动创建；如果目标文件夹已经存在，它会忽略这个操作。同时，它还会沿途创建所有不存在的文件夹（类似 mkdir 的 -p 参数）。\r方法二：不使用递归 \u0026para; 如果不希望使用递归，那么也可以通过相对路径的方式来实现。这个方法会递归搜索源文件夹下的所有文件，通过计算它与源文件夹的相对路径来得到它的目标路径，进而生成目标路径所在的文件夹。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 static void CopyDirectory(string sourceFolderPath, string targetFolderPath) { Directory.CreateDirectory(targetFolderPath); foreach (string filePath in Directory.GetFiles(sourceFolderPath, \u0026#34;*.*\u0026#34;, SearchOption.AllDirectories)) { var relativePath = Path.GetRelativePath(sourceFolderPath, filePath); var targetFilePath = Path.Combine(targetFolderPath, relativePath); var subTargetFolderPath = Path.GetDirectoryName(targetFilePath); if (subTargetFolderPath != null) Directory.CreateDirectory(subTargetFolderPath); File.Copy(filePath, targetFilePath); } } Tip\rPath.GetDirectoryName 方法有可能返回空。这一情况通常发生在文件位于根目录的情况（例如 Windows 的 C:\\，或 Unix 的 /）。\r使用 VisualBasic 的内置方法 \u0026para; 其实 .NET 也不是完全没有提供内置的方法。比如我们可以使用 VisualBasic 的 Microsoft.VisualBasic.Devices 命名空间下的 Computer 类上的 FileSystem 成员的方法来实现拷贝文件夹的功能：\n1 2 3 4 5 6 7 8 using Microsoft.VisualBasic.Devices; using Microsoft.VisualBasic.FileIO; static void CopyDirectory(string sourceFolderPath, string targetFolderPath) { fs = new Computer().FileSystem; fs.CopyDirectory(sourceFolderPath, targetFolderPath, UIOption.OnlyErrorDialogs); } 可能有读者想说，作者你怎么不早点拿出这个方法呢？这方法多么地简单易用啊！\n实际上，这个方法也是有显著缺点的：需要使用 WinForms 相关的库。也就是说，你的项目需要 TargetFramework 包含 -windows，并且还要 UseWindowsForms。\n如果你在开发 WPF 或 WinForms 程序，那么这通常是可以接受的。但如果你是在开发控制台程序、ASP.NET 程序，又或者 Avalonia UI 等跨平台框架，那么这个方法显然就有些 unacceptable 了。\nTip\r其实 VisualBasic 还提供了一些别的实用功能，比如将文件移至回收站，就可以用 FileSystem.DeleteFile 方法，并添加 RecycleOption.SendToRecycleBin 参数来实现。这个方法会将文件移至回收站，而不是直接删除。\r总结 \u0026para; 本文介绍了三种拷贝文件夹的方法，分别是使用递归、不使用递归、以及使用 VisualBasic 的内置方法。这三种方法各有优劣，读者可以根据自己的需求来选择适合的方法。\nWarning\r在拷贝文件夹时，一定要注意文件夹的权限问题。如果源文件夹或目标文件夹的权限不足，那么拷贝操作可能会失败。\r","date":"2024-12-11T00:00:00Z","image":"https://s2.loli.net/2024/12/11/9swekVbJFzX3DfH.jpg","permalink":"https://blog.coldwind.top/posts/how-to-copy-folder/","title":"如何在 C# 中拷贝一个文件夹"},{"content":"我们在做 .NET 开发时，经常要和各种图片的数据类型打交道。这里指的“类型”并不是图片的文件类型，比如 jpg、png、bmp 等，而是图片数据在内存中的表示方式。这些类型之间的转换，有时候会让人感到困惑。本文总结了常见的图片数据类型之间的转换方法，希望能帮助大家理清思路。\n常见的图片数据类型有：\nbyte[] 字节数组：可能有两种情况： 将图片文件读取到内存后得到的字节数组，包括图片文件的文件头等 图片的像素数据，比如 RGB 数据 Stream：数据流，比如 MemoryStream、FileStream 等，一般和字节数组可以轻易地相互转换 Bitmap：WinForms 中的图片数据类型（基于 GDI+），命名空间是 System.Drawing BitmapImage：WPF 中的图片数据类型，命名空间是 System.Windows.Media.Imaging，常用于 Image 控件的 Source 属性（是 ImageSource 类型） BitmapSource：WPF 中的图片数据类型，命名空间是 System.Windows.Media，是 BitmapImage 的基类 其他一些来自第三方库的图片类型 将图片文件路径转为 BitmapImage \u0026para; 如果我们知道图片的链接（可以是本地链接或网址），并且想让 Image 控件显示这个图片，最简单的方式如下：\n1 2 var image = new Image(); image.Source = new BitmapImage(new Uri(@\u0026#34;path\\to\\image.jpg\u0026#34;, UriKind.RelativeOrAbsolute)); 上述方式甚至都不需要指定图片的格式，因为 BitmapImage 和 BitmapDecoder 都会自动进行处理。对于大多数常见的图片格式（如 JPG、PNG、BMP、GIF、TIFF、WebP、HEIC、AVIF 等），这几种方式都能正常工作。但如果是一些不太常见的图片格式，则可能需要借助一些第三方库才行了。\n另外，如果我们并没有图片的路径，只有它被读进内存后的数据类型，那么就需要下面的几种方式了。\nBitmap 转为 BitmapImage \u0026para; System.Drawing.Bitmap 和 System.Windows.Media.Imaging.BitmapImage 是两个常见的图片数据类型。前者是 WinForms 中的类型（GDI+），后者是 WPF 的类型。它们之间的转换方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using System.Drawing; using System.Windows.Media.Imaging; static BitmapImage ConvertBitmapToBitmapImage(Bitmap bitmap) { using var stream = new MemoryStream(); bitmap.Save(stream, ImageFormat.Png); stream.Position = 0; var bitmapImage = new BitmapImage(); bitmapImage.BeginInit(); bitmapImage.CacheOption = BitmapCacheOption.OnLoad; bitmapImage.StreamSource = stream; bitmapImage.EndInit(); bitmapImage.Freeze(); // （可选）冻结图片，提高性能和线程安全性 return bitmapImage; } 字节数组转为 ImageSource \u0026para; 这里有两种情况。如果字节数组只是读进内存的图片文件数据，比如一个本地的 JPG、PNG、BMP 等格式的文件，那么非常简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 using System.IO; using System.Windows.Media.Imaging; static ImageSource ConvertByteArrayToImageSource(byte[] bytes) { using var stream = new MemoryStream(bytes); var bitmapImage = new BitmapImage(); bitmapImage.BeginInit(); bitmapImage.CacheOption = BitmapCacheOption.OnLoad; bitmapImage.StreamSource = stream; bitmapImage.EndInit(); bitmapImage.Freeze(); return bitmapImage; } 还有一种更简单的方式，直接使用 BitmapDecoder 类：\n1 2 3 4 5 6 7 8 9 using System.Windows.Media.Imaging; static ImageSource ConvertByteArrayToImageSource(byte[] bytes) { using var stream = new MemoryStream(bytes); return BitmapDecoder .Create(stream, BitmapCreateOptions.PreservePixelFormat, BitmapCacheOption.OnLoad) .Frames[0]; } 如果字节数组是图片的像素数据，比如从左上到右下的逐行 RGB 数据，那么会麻烦一些，而且我们需要有办法知道图片的宽高等信息：\n1 2 3 4 5 6 7 8 9 10 11 using System.Windows.Media; using System.Windows.Media.Imaging; static ImageSource BgrByteArrayToImageSource(byte[] array, int width, int height, int channel = 3, int? stride = null) { var bmp = new WriteableBitmap(width, height, 96, 96, PixelFormats.Bgr24, null); stride ??= ((width * channel + 3) / 4) * 4; bmp.WritePixels(new Int32Rect(0, 0, width, height), array, stride.Value, 0); bmp.Freeze(); return bmp; } BitmapSource 转为 BitmapImage \u0026para; 这两个类其实是有继承关系的，BitmapImage 继承自 BitmapSource。但一般我们仍然需要进行一个“转换”，因为通常的使用场景是，我们从 WPF 提供的剪贴板 API 中获取到一个 BitmapSource，但我们经过简单的处理，将它转为 BitmapImage 从而添加给 Image 控件。这时候可以这样转换：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 using System.Windows.Media.Imaging; static BitmapImage ConvertBitmapSourceToBitmapImage(BitmapSource bitmapSource) { var bitmapImage = new BitmapImage(); using var stream = new MemoryStream(); BitmapEncoder encoder = new BmpBitmapEncoder(); // 一般情况下，剪贴板中的图片数据是 BMP 格式的，而非 PNG 格式 encoder.Frames.Add(BitmapFrame.Create(bitmapSource)); encoder.Save(stream); stream.Position = 0; bitmapImage.BeginInit(); bitmapImage.CacheOption = BitmapCacheOption.OnLoad; bitmapImage.StreamSource = stream; bitmapImage.EndInit(); bitmapImage.Freeze(); return bitmapImage; } Emgu.CV.Image 转为 BitmapImage \u0026para; 前面我们提到，BitmapImage 支持绝大多数常见的图片格式。但如果现在我们有一个不常见的格式，比如 JP2（JPEG 2000）格式，那么 BitmapImage 就无法直接处理了。这时候我们可以使用 Emgu.CV 库，它是 OpenCV 的 .NET 封装，支持更多的图片格式。下面给出一种方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var filename = @\u0026#34;path\\to\\image.jp2\u0026#34;; var mat = new Image\u0026lt;Bgr, Byte\u0026gt;(filename); var bytes = mat.ToJpegData(); using var stream = new MemoryStream(bytes); var bitmap = new BitmapImage(); bitmap.BeginInit(); bitmap.CacheOption = BitmapCacheOption.OnLoad; bitmap.StreamSource = stream; bitmap.EndInit(); bitmap.Freeze(); var control = new Image(); control.Source = bitmap; control.Dump(); 总结 \u0026para; 看了这么多，大家相信已经看出规律了吧？是的，对于大多数情况，我们都要先将数据转为持有常见图像类型的 Stream，然后再创建 BitmapImage，最后将其赋给 Image 控件。这样的方式，可以保证我们的代码在大多数情况下都能正常工作。\n","date":"2024-11-19T00:00:00Z","image":"https://s2.loli.net/2024/11/19/bqvEn9ipfu7DPem.jpg","permalink":"https://blog.coldwind.top/posts/image-datatypes-conversion/","title":"常见图片相关的数据类型之间的转换"},{"content":"在 WPF 开发中，我们可以给控件添加 Name 或 x:Name 属性。这样做的目的通常是希望在代码后台能够访问这个控件，或者我们在写 Binding 表达式时，希望使用 ElementName 的方式绑定某个控件。那么这二者究竟是什么区别呢？本文就来简单探讨一下。\n本质不同，但却又几乎相同 \u0026para; 别的暂且不谈，我们只关注 XML 文档的命名空间，不难发现 Name 和 x:Name 的区别在于前者没有命名空间，而后者有一个 x 命名空间。具体来说，通常我们的一个 XAML 文件的根元素是这样的：\n1 2 3 4 5 6 \u0026lt;Window x:Class=\u0026#34;WpfApp1.MainWindow\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; Title=\u0026#34;MainWindow\u0026#34; Height=\u0026#34;450\u0026#34; Width=\u0026#34;800\u0026#34;\u0026gt; \u0026lt;!-- 省略其他内容 --\u0026gt; \u0026lt;/Window\u0026gt; 其中，xmlns 是默认的命名空间，而 xmlns:x 是 x 命名空间。所以，x:Name 和 Name 分别出自哪个命名空间，就不言而喻了。\n但是，虽然它们两个出身不同，但在 WPF 中，它们的作用几乎是一样的。具体来说，Name 是 FrameworkElement 类（以及 FrameworkContentElement 类，下略）的一个依赖属性，形如（为便于阅读，代码略有删改）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [CommonDependencyProperty] public static readonly DependencyProperty NameProperty = DependencyProperty.Register( \u0026#34;Name\u0026#34;, typeof(string), typeof(FrameworkElement), new FrameworkPropertyMetadata(/* ... */); [Localizability(LocalizationCategory.NeverLocalize)] [MergableProperty(false)] [DesignerSerializationOptions(DesignerSerializationOptions.SerializeAsAttribute)] public string Name { get { return (string) GetValue(NameProperty); } set { SetValue(NameProperty, value); } } 而进一步观察 FrameworkElement 类的声明，我们可以发现：\n1 2 3 4 5 6 7 8 namespace System.Windows { [RuntimeNamePropertyAttribute(\u0026#34;Name\u0026#34;)] public partial class FrameworkElement { // ... } } 这里的 RuntimeNamePropertyAttribute 是一个特性，它告诉 WPF 运行时，FrameworkElement 类的 Name 属性将会被转为 x:Name 属性。所以，Name 和 x:Name 在 WPF 中几乎是一样的。\n至于为什么要这样设计，我并没有找到官方的答案。唯一合理的猜测，就是想给开发者一个较为方便的方式去给控件命名。毕竟，Name 比 x:Name 看起来更简洁，更加直观（毕竟这看起来就是属于控件自己的名字一样），而且还不需要使用命名空间。\nx:Name 本质上意味着什么？ \u0026para; 那么，既然二者并没有多少区别，我们现在就来看一看 x:Name 到底意味着什么。在 XAML 中，当我们给控件添加 x:Name 属性时，实际上是在告诉 XAML 解析器，这个控件的名字是什么。并且相信大家都知道，拥有了名字的控件，它就会变成类的字段，我们可以在代码后台通过这个名字来访问它。\n具体来说，以 Window 为例，我们会发现后台代码是一个分部类。在我们看不到的地方，XAML 解析器会生成一个类。这个类中就有我们最熟悉的在构造函数中调用的 InitializeComponent 方法，以及我们在 XAML 中添加了 Name 的控件所对应的字段。例如，我们在 XAML 中这样写：\n1 2 3 4 5 6 7 \u0026lt;Window x:Class=\u0026#34;WpfApp1.MainWindow\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; Title=\u0026#34;MainWindow\u0026#34; Height=\u0026#34;450\u0026#34; Width=\u0026#34;800\u0026#34;\u0026gt; \u0026lt;Button x:Name=\u0026#34;button1\u0026#34; Content=\u0026#34;Click Me\u0026#34; /\u0026gt; \u0026lt;Button x:Name=\u0026#34;button2\u0026#34; x:FieldModifier=\u0026#34;private\u0026#34; Content=\u0026#34;Click Me\u0026#34; /\u0026gt; \u0026lt;/Window\u0026gt; 那么，我们就能在后台生成的代码（文件名类似 MainWindow.g.i.cs）中找到这样的内容（我们可以在后台随便一个地方访问这个字段，然后用 IDE 的跳转到定义的方式找到后台生成的代码）：\n1 2 3 4 5 public partial class MainWindow : // ... { internal System.Windows.Controls.Button button1; private System.Windows.Controls.Button button2; } 此外，如果 XAML 中的一个控件拥有了 Name，我们还可以实现一些别的事情。包括但不限于：\n在 Binding 表达式中使用 ElementName 来绑定这个控件； 在 Storyboard 中使用 TargetName 来指定这个控件； 在后台代码中使用 FindName 方法来查找这个控件。 总结 \u0026para; 本文简单介绍了 WPF 中的 Name 和 x:Name 属性。虽然它们在本质上有一些区别，但在 WPF 中，它们的作用几乎是一样的。\n围绕着 Name 这个概念，其实能聊的还有很多。比如：\nNameScope 的概念； 当持有 Name 的控件在 ControlTemplate 或 DataTemplate 中时会怎样； 与之相关的其他来自 x 命名空间的属性，比如 x:FieldModifier、x:Reference 等。 这些内容，我们会在以后的文章中继续探讨。\n参考 \u0026para; In WPF, what are the differences between the x:Name and Name attributes? x:Name Directive | Microsoft Learn ","date":"2024-10-10T00:00:00Z","image":"https://s2.loli.net/2024/10/11/jurJoLAN3aWBgZ6.png","permalink":"https://blog.coldwind.top/posts/wpf-name-vs-xname/","title":"WPF 中的 Name 与 x:Name 究竟是什么区别？"},{"content":"我们继续上一次的内容，再来看一看关于 XML 内容读取有哪些意想不到的性能差别。这次我们用于演示的 XML 文本依旧是来自 W3Schools 的一个样例，大致内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;breakfast_menu\u0026gt; \u0026lt;food\u0026gt; \u0026lt;name\u0026gt;Belgian Waffles\u0026lt;/name\u0026gt; \u0026lt;price\u0026gt;$5.95\u0026lt;/price\u0026gt; \u0026lt;description\u0026gt;Two of our famous Belgian Waffles with plenty of real maple syrup\u0026lt;/description\u0026gt; \u0026lt;calories\u0026gt;650\u0026lt;/calories\u0026gt; \u0026lt;/food\u0026gt; \u0026lt;!-- 省略中间的三个 food --\u0026gt; \u0026lt;food\u0026gt; \u0026lt;name\u0026gt;Homestyle Breakfast\u0026lt;/name\u0026gt; \u0026lt;price\u0026gt;$6.95\u0026lt;/price\u0026gt; \u0026lt;description\u0026gt;Two eggs, bacon or sausage, toast, and our ever-popular hash browns\u0026lt;/description\u0026gt; \u0026lt;calories\u0026gt;950\u0026lt;/calories\u0026gt; \u0026lt;/food\u0026gt; \u0026lt;/breakfast_menu\u0026gt; 我们这次的任务是：获取最后一个 food 的 calories 的值（即 950）。这次我们的选手有：LINQ to XML、XPath 以及正则表达式。对于 XPath，我们同样在 XDocument 上进行操作（只需要引入 System.Xml.XPath 命名空间即可）。\nLINQ to XML \u0026para; 我们先来看一看 LINQ to XML（即 System.Xml.Linq 命名空间）该如何实现吧。\n1 2 3 4 5 6 public int Elements() { var foods = doc.Root.Elements(\u0026#34;food\u0026#34;); var lastFood = foods.Last(); return (int)lastFood.Element(\u0026#34;calories\u0026#34;); } 其实，这里因为我们很清楚 XML 文档的结构，所以上面的内容可以简化为：\n1 2 public int Elements() =\u0026gt; (int)doc.Root.Elements().Last().Elements().Last(); 这样是可以提高一点性能的，因为我们不需要检查每个节点的名字。\n另外，我们还可以使用 Descendants 这个方法，从而减少一些 Elements 的调用。最极端的情况下，因为我们要获取的元素正好是最后一个，所以我们甚至别的什么都不用做，直接调用 Descendants 就可以了：\n1 2 public int Descendants() =\u0026gt; (int)doc.Root.Descendants().Last(); XPath \u0026para; 接下来我们看一看使用 XPath 表达式该如何实现：\n1 2 public int XPath() =\u0026gt; (int)doc.XPathSelectElement(\u0026#34;//food[last()]/calories\u0026#34;); 这里我们借助 XPath 表达式的特殊语法，直接选取了最后一个 food 节点的 calories 子节点。或者，因为我们知道总共五个 food 节点，所以我们也可以将上面的 last() 替换为 5。这样确实会换来一点点提升，但是非常不明显，而且有耍赖的嫌疑，所以我们就不这么做了。\n上面的方式其实效率并不是最高的，因为 //food 会搜索整个 XML 文档，寻找所有名称为 food 的节点。如果我们能够将 XPath 表达式写得更加精确，是能够提升一些性能的：\n1 2 public int XPathOptimized() =\u0026gt; (int)doc.XPathSelectElement(\u0026#34;/breakfast_menu/food[last()]/calories\u0026#34;); 这样，我们就只需要搜索 breakfast_menu 节点下的 food 节点，而不是整个文档了。这个不经意的小改动，就能够带来显著的性能提升（约 4~5 倍！）。\n正则表达式 \u0026para; 最后，我们再来看一看正则表达式的实现。这个实现方式就非常简单粗暴了。我们只需要匹配 calories 节点，并拿到最后一个的值即可：\n1 2 3 4 5 6 7 private readonly Regex regex = new Regex(@\u0026#34;\u0026lt;calories\u0026gt;(\\d+)\u0026lt;/calories\u0026gt;\u0026#34;); public int Regex() { var matches = regex.Matches(xml); return int.Parse(matches[^1].Groups[1].Value); } 但其实我们仍然有相当大的优化空间。因为我们这里需要的是最后一个 calories 节点，所以我们不需要匹配全部的 calories 节点，只需要匹配到最后一个即可。实现这一操作的方式，除了修改表达式本身以外，我们还可以借助 RegexOptions.RightToLeft 这个选项：\n1 2 3 4 5 6 7 private readonly Regex regex = new Regex(@\u0026#34;\u0026lt;calories\u0026gt;(\\d+)\u0026lt;/calories\u0026gt;\u0026#34;, RegexOptions.RightToLeft); public int RegexOptimized() { var match = regex.Match(xml); return int.Parse(match.Groups[1].Value); } 通过这样的一个简单操作，我们再次可以换来约 4~5 倍的性能提升。\n性能对比 \u0026para; 现在，我们可以来看一看比赛的结果了：\nMethod Mean Error StdDev Gen0 Gen1 Allocated Elements 101.3 ns 10.07 ns 0.55 ns 0.0101 0.0001 128 B Descendants 243.4 ns 26.84 ns 1.47 ns 0.0062 0.0005 80 B RegexMatch 605.7 ns 158.79 ns 8.70 ns 0.1278 0.0010 1608 B RegexMatchOptimized 128.1 ns 59.86 ns 3.28 ns 0.0305 0.0002 384 B XPathOptimized 1,297.4 ns 927.55 ns 50.84 ns 0.3681 0.0038 4624 B XPath 5,099.2 ns 1,591.05 ns 87.21 ns 0.8087 0.0076 10208 B 不知道这样的结果有没有出乎大家的意料呢？不难发现，看似不起眼的 LINQ to SQL 方法，居然能轻易击败了优化过的正则表达式以及 XPath，尤其是 XPath 的速度居然会这么慢，进入了微秒级别。\n另一方面，在上一次比赛中胜出的正则表达式，这次居然也不敌 LINQ to XML，尤其是如果不优化，那么正则表达式的性能还要再差上不少。\n所以，这次的跑分再次向我们证明，对于 XML 文档的读取，LINQ to XML 是最好的选择，可以说是不仅好用，而且高效。\nOne More Thing \u0026para; 说到跑分，这种时候怎么少得了 Span 呢？\n1 2 3 4 5 public int Span() { var xml = Xml.AsSpan(); return int.Parse(xml.Slice(xml.LastIndexOf(\u0026#34;\u0026lt;calories\u0026gt;\u0026#34;) + 10, xml.LastIndexOf(\u0026#34;\u0026lt;/calories\u0026gt;\u0026#34;) - (xml.LastIndexOf(\u0026#34;\u0026lt;calories\u0026gt;\u0026#34;) + 10))); } 至于结果嘛：\nMethod Mean Error StdDev Ratio RatioSD Allocated Span 22.30 ns 0.435 ns 0.024 ns 0.22 0.00 - ","date":"2024-09-27T00:00:00Z","image":"https://s2.loli.net/2024/10/11/XEIhj5DuRS6Wa4n.png","permalink":"https://blog.coldwind.top/posts/xml-read-benchmarks-2/","title":"如何高效读取 XML 中所需的内容（其二）"},{"content":"在我们的学习与生活中，信息差可以说是无处不在。所谓“信息差”，其实就是因为不同的人的见识、经历、机会等的不同，而产生的一种所了解的信息的不平等的现象。这一现象将会导致掌握更多信息的一方在某些情况下具有显著的优势。有一个经典的寓言故事，“拧这颗螺丝值 1 美元，而知道要拧这颗螺丝值 999 美元”。这其实就是信息差。\n认识信息差 \u0026para; 信息差是客观存在且几乎不可能消除的。韩愈在《师说》中提到，“闻道有先后，术业有专攻”。每个人去学习并了解一样事物的早晚和快慢都是不同的。有的人可能是相关经验比较丰富，或从小就对某样东西充满了兴趣和探索的欲望，又或者运气好，早早就找到了点醒自己的学习资料。也因此，他们早早地掌握了更多的信息，并且基于这些信息，又能够如同指数爆炸一样，快速接受更多的内容。这就是一种优势。\n比如最近大火的游戏《黑神话·悟空》，就会出现一种分歧：一部分人觉得，这游戏并不难啊，一些比较厉害的 BOSS 网上很容易找到攻略，直接“耍赖皮”就能过关；而也有一些不擅长动作类游戏，或者说不擅长各种游戏、只是因为游戏的热度和对于剧情的兴趣慕名而来的玩家们就会叫苦不迭，因为游戏还没有提供难度选择。不是所有人都会越挫越勇，屡战屡败本身就很可能消磨人的意志，最终产生负面情感。但前者就会觉得，你们就是菜、就是懒，明明网上大把的攻略，你们都懒得找。\n早些年深度学习很火的时候，国内有一些卖课的博主，他们只是把斯坦福大学的 CS231N 的课件拿过来就能放在知乎割大把的韭菜；电商平台时常会见到的“i7 级处理器”和只要九块九的 1T 容量的 U 盘，这种看似“明显”的骗局却屡屡有人中招；机圈人尽皆知的搭载骁龙 680 的电子垃圾，却有可能被人以 2000 元的价格买走……这样的例子数不胜数，但它们也终究是一直并将长期存在着。这些都是因为信息差导致的。\n理解信息差 \u0026para; 但是我们仅仅认识到信息差的存在是不够的。重要的是，我们要理解信息差。为什么这么说呢？还是上面提到的《黑神话》的例子。或许你知道某个 BOSS 有一个很偷鸡很轻松的打法，但是你比那些“菜鸟”多知道的，其实远不仅仅是“有这个打法”。很有可能是，你在发现这篇攻略之前，已经在相关的社区和论坛沉浸了数个小时。或许这时在你看来，只要在搜索引擎里面简单敲几个字，就能再找到这一篇；可这对于一个完全不了解这方面信息的人来说，所欠缺的时间，可能是巨大的。\n在每个领域都是，就比如我和我的绝大多数读者们所处的 .NET 这一领域。或许有一个知识、一个概念、一个技巧对于你来说仿佛家常便饭，相应的博客文章、视频教程、官方文档你可以信手拈来；或许有一个问题，身经百战的你一看报错信息就知道是因为配错了环境，但是却可能让新手在百度上搜索了半天，最后找到了一篇机翻的 CSDN 文章才勉强解决问题；一个简单的接口、依赖注入，对于你来说早已经是轻车熟路、老生常谈，却依旧能够轻易地困惑一个非 CS 科班出身的新手数年。很多时候，人和人之间的差别并不是智商，而是信息。\n虽然我明白这个道理，但我也经常会不由自主地去产生不好的情感。比如我经常会在弹幕或评论区看到有人问主题配色和字体用的是什么，或者问一些我早就有相关视频探讨过的内容。明明我已经专门出了视频、在很多处评论给出了解答，还专门写了置顶专栏来解答常见问题，可就是有人不知道。但是换位思考，当我正在看油管上的 Tim Corey、Nick Chapsas、Brian Launas 这些大佬的视频的时候，除非我把他们的所有视频都大致刷了一遍，否则我依旧要花时间去搜索、去研究、去搞懂。我仍记得，第一次看 Brian 的视频时，他项目中使用了 Prism 框架，但是我并不知道他一直都是这样做的，所以第一次看到他的 MVVM 框架“莫名其妙”地自动实现了一些功能时完全一脸懵逼。而这一点，对于他的其他观众而言，简直可以说是“常识”——是的，每个人都有自己的“常识”，而且有可能和别人的交集占比并不大。\n也因此，每次我介绍 MVVM 相关的内容时，我会尽量多说两句 MVVM 社区工具包的原理，从而让之前没接触过的观众不至于搞不清楚那些看不到的属性是哪儿来的；看到问主题颜色和字体的问题时，我也时刻提醒自己，我知道我在很多地方提供了回答，也依旧是不够的——我现在已经有一百多期视频了，连我自己有时候都搞不清楚某个知识点我到底有没有讲过。甚至因为我用了包含连字符的字体，导致代码中有时候会出现诸如“≠”的符号，我现在都觉得有些不妥。这里给看我 MVVM 工具包视频并且因为这些符号感到困惑过的观众朋友们道个歉。\n重视信息差 \u0026para; 前面我们说了，对于信息差，我们要认识、要理解，但同时，我们还要重视。什么是重视呢？我们要知道，虽然我们可能比其他人碰巧多知道了一些知识，从而使我们在某些时候占据了优势，但是我们也要时常反思。“吾日三省吾身”，因为信息差客观存在，别人有欠缺的信息，我们极有可能也有，而且可能还有不少。所以，谁也别瞧不起谁。每个人都有自己的盲区，都有自己还不熟悉的领域。在这个信息爆炸的时代，我们永远都不要只活在自己的舒适区，要敢于跳出自己的成见，去了解、去学习、去接受新的事物。\n人怎样才能进步呢？程序员的进步，不是靠着写相同的代码写 10000 遍，而是靠着每天都能写点之前从来没写过的代码，思考一些以前没想过或没相同的事情。每天都做自己认为对的事情，或许并没有进步；每天意识到曾经的自己犯过一些错误，这才是吐故纳新。要敢于承认自己的不足，正视自己的缺点，笑对别人的鄙夷。相信将来的自己，回过头来，会觉得一路走来，每一次“难受”都是值得的。\n除此之外，我们还有另外一个层面的“重视”——我们要警惕别人利用信息差来欺骗或蒙蔽自己。有的人掌握了信息差，或许只是妄自尊大、盲目自信、充满了优越感；但更有一部分人，会特意借助信息差来收“智商税”。这样的例子在我们的生活中可以说是无处不在，不管是网店、二手交易平台、网课平台，还是各种中介、招聘平台等等。我们一定要擦亮自己的眼睛。\n结语 \u0026para; 最后，希望大家都能够理解信息差，要时刻怀着一种“自己还有很多不知道的东西”的态度，努力学习，尽力减少此类情形。另一方面，我们还要提高警惕，因为可能会有人借助信息差来欺骗我们。面对那些当下掌握了比自己少的信息的人，不要嗤之以鼻，而是友好相处，伸出援手。毕竟，把自己掌握的知识教会给别人，不正是践行了费曼学习法、证明自己确实掌握了这个知识吗？只有每个人都这样，我们才能建设一个良好的社区环境。\n","date":"2024-09-23T00:00:00Z","permalink":"https://blog.coldwind.top/posts/notice-understand-info-asymmetry/","title":"要认识、理解、重视信息差"},{"content":" 本文有对应的视频教程：哔哩哔哩\n相信无数 WPF 开发者在开发过程中，都会遭受过很多这样或那样的痛苦，比如：\n在设计 TextBlock 控件时，因为无法预览字体、字号、颜色等属性，导致需要临时给 Text 属性赋一个值，查看效果后再删除； 有一个默认折叠的 Expander 控件，但是在设计时无法看到折叠后的效果，只能在运行时查看，或者临时修改 IsExpanded 属性； Window 的 DataContext 因为在后台代码中赋值，导致在设计时无法看到绑定的数据，也无法在书写绑定时获得智能提示。 如果你有过这样的困扰，那么这篇文章一定可以帮助到你。本文将介绍 WPF 中设计时特性的使用方法，让你在设计时就能看到更多的效果，提高开发效率。\n基本概念 \u0026para; 设计时特性（Design-Time Attributes）是 WPF 中的一种特性，用于在设计时为控件提供更多的信息，以便在设计时能够更好地预览控件的效果。这一功能其实默认一直都是开启的，只是我想可能很多开发者都没有注意过。比如我们在 WPF 中新建一个 UserControl，那么就会在 XAML 的开头看到类似这样的代码：\n1 2 3 4 5 6 7 8 \u0026lt;UserControl x:Class=\u0026#34;WpfApp1.MyUserControl\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; mc:Ignorable=\u0026#34;d\u0026#34; d:DesignHeight=\u0026#34;450\u0026#34; d:DesignWidth=\u0026#34;800\u0026#34;\u0026gt; \u0026lt;/UserControl\u0026gt; 在开头，模板自动为我们添加了很多 XML 命名空间（xmlns），但是很多开发者可能只了解 xmlns 与 xmlns:x 这两个，而往往忽略了另外的几个。但其实另外的几个（xmlns:mc、xmlns:d）就提供了设计时特性的支持。最典型的例子就比如上面的d:DesignHeight和d:DesignWidth，这两个属性就是用来在设计时指定控件的高度和宽度的。这些特性最大的特点就是，它们只在设计时起作用，不会影响运行时的效果。\n了解了这些基本概念后，我们就可以开始介绍一些常用的设计时特性了。\n常用设计时特性 \u0026para; 比如 TextBlock 的 Text 在设计时并没有内容（比如是 DynamicResource 从运行时加载的语言文件中获取，或绑定了 ViewModel 中的属性，但是设计时这个属性没有值，却又想预览字体效果，这时候就可以使用 d:Text 来指定设计时的文本内容：\n1 \u0026lt;TextBlock Text=\u0026#34;{DynamicResource ResourceKey=HelloWorld}\u0026#34; d:Text=\u0026#34;Hello, World!\u0026#34; /\u0026gt; 这样在设计时就可以看到 Hello, World! 这个文本了。\n如果 TextBlock 的内容是用多个 Run 组合而成，那么我们也可以用这样的方式来实现：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;TextBlock\u0026gt; \u0026lt;d:TextBlock.Inlines\u0026gt; \u0026lt;Run Text=\u0026#34;Hello, \u0026#34; /\u0026gt; \u0026lt;Run Text=\u0026#34;World!\u0026#34; FontWeight=\u0026#34;Bold\u0026#34; /\u0026gt; \u0026lt;/d:TextBlock.Inlines\u0026gt; \u0026lt;/TextBlock\u0026gt; \u0026lt;!-- 或者也可以用下面将要介绍的虚拟控件 --\u0026gt; \u0026lt;d:TextBlock\u0026gt; \u0026lt;Run Text=\u0026#34;Hello, \u0026#34; /\u0026gt; \u0026lt;d:Run Text=\u0026#34;World!\u0026#34; FontWeight=\u0026#34;Bold\u0026#34;/\u0026gt; \u0026lt;/d:TextBlock\u0026gt; 其他类似的例子还比如：\n有一个只在特殊情况下才会展示的进度条，希望查看它的效果：d:Visibility=\u0026quot;Visible\u0026quot; 有一个平时默认折叠的面板，想查看效果：d:IsExpanded=\u0026quot;True\u0026quot; 一个用户控件，想给它一个相对合理的默认大小：d:DesignHeight=\u0026quot;600\u0026quot; 或 d:Height 一个下拉框，想查看选中项的预览效果：d:SelectedIndex=\u0026quot;0\u0026quot; 一个导航用的 ContentControl，我们希望预览导航到某一页的效果，就可以写 d:ContentControl.Content Info\r关于上面的第 5 个例子，为什么我们直接将想要导航的内容以下面要提到的虚拟控件的方式添加到 ContentControl 之中呢？因为通常来说，我们写的导航页面是借助 UserControl 实现的，而它的命名空间通常为 xmlns:local 等。对于这样的命名空间，我们没有办法使用 d: 技巧，所以这里我们选择为 ContentControl 的 Content 属性添加 d: 特性。\r虚拟控件 \u0026para; 我们不仅可以借助设计时特性来实现控件某些属性的虚拟，还可以虚拟整个控件出来：\n1 \u0026lt;d:Button Content=\u0026#34;Virtual Button\u0026#34; Style=\u0026#34;{StaticResource MyButtonStyle}\u0026#34; /\u0026gt; 这样就可以在设计时看到一个虚拟的按钮了，而不需要在运行时才能看到效果。这一技巧可以用来预览按钮的样式。\n还有一种常见情形是，我们设计的软件会让用户去手动添加一些项目，从而动态生成对应的控件。对于这样的情况，我们如果能在设计时就看到一些“生成”出来的控件，那么就能更好地开发样式了。此时，我们添加一些虚拟控件，就可以满足这个需求。\n1 2 3 4 5 6 7 \u0026lt;ItemsControl\u0026gt; \u0026lt;d:ItemsControl.Items\u0026gt; \u0026lt;Button Content=\u0026#34;Button 1\u0026#34; /\u0026gt; \u0026lt;Button Content=\u0026#34;Button 2\u0026#34; /\u0026gt; \u0026lt;Button Content=\u0026#34;Button 3\u0026#34; /\u0026gt; \u0026lt;/d:ItemsControl.Items\u0026gt; \u0026lt;/ItemsControl\u0026gt; 设计时数据 \u0026para; 这段内容可以说是重中之重了。很多开发者苦恼于因为在 Window 的代码后台通过 this.DataContext = new ViewModel(); 来添加 ViewModel，导致在设计时无法看到绑定的数据，也无法获得智能提示。这时候我们可以使用 d:DataContext 来指定设计时的数据：\n1 2 3 \u0026lt;Window ... d:DataContext=\u0026#34;{d:DesignInstance Type=vm:MainViewModel}\u0026#34;\u0026gt; \u0026lt;/Window\u0026gt; DesignInstance 还有一个 IsDesignTimeCreatable 属性，用于指定是否在设计时创建实例。如果设为 True，还将能够在设计时看到一些 ViewModel 中属性的默认值。\n或者我们还可以这样写，并且还可以在 XAML 中定制一些 ViewModel 的属性的初始值，便于观察效果：\n1 2 3 4 5 \u0026lt;Window ...\u0026gt; \u0026lt;d:DataContext\u0026gt; \u0026lt;vm:MainViewModel Message=\u0026#34;Hello!\u0026#34; /\u0026gt; \u0026lt;/d:DataContext\u0026gt; \u0026lt;/Window\u0026gt; 列表项 \u0026para; 如果我们有一个 ListBox，并且想要查看列表项的效果，可以这样：\n1 2 3 4 5 6 7 8 9 \u0026lt;ListBox ItemsSource=\u0026#34;{Binding Students}\u0026#34;\u0026gt; \u0026lt;d:ListBox.ItemsSource\u0026gt; \u0026lt;x:Array Type=\u0026#34;model:Student\u0026#34;\u0026gt; \u0026lt;model:Student Name=\u0026#34;Alice\u0026#34; Age=\u0026#34;18\u0026#34; /\u0026gt; \u0026lt;model:Student Name=\u0026#34;Bob\u0026#34; Age=\u0026#34;19\u0026#34; /\u0026gt; \u0026lt;model:Student Name=\u0026#34;Charlie\u0026#34; Age=\u0026#34;20\u0026#34; /\u0026gt; \u0026lt;/x:Array\u0026gt; \u0026lt;/d:ListBox.ItemsSource\u0026gt; \u0026lt;/ListBox\u0026gt; 如果不想写 x:Array，而是希望采用传统的为 Items 添加控件的方式添加预览项，也可以这样：\n1 2 3 4 5 6 7 \u0026lt;ListBox ItemsSource=\u0026#34;{Binding Students}\u0026#34; d:ItemsSource=\u0026#34;{x:Null}\u0026#34;\u0026gt; \u0026lt;ListBox.Items\u0026gt; \u0026lt;ListBoxItem\u0026gt;Student 1\u0026lt;/ListBoxItem\u0026gt; \u0026lt;ListBoxItem\u0026gt;Student 2\u0026lt;/ListBoxItem\u0026gt; \u0026lt;ListBoxItem\u0026gt;Student 3\u0026lt;/ListBoxItem\u0026gt; \u0026lt;/ListBox.Items\u0026gt; \u0026lt;/ListBox\u0026gt; 这里额外写一个 d:ItemsSource=\u0026quot;{x:Null}\u0026quot; 是因为 ItemsSource 和 Items 两个属性不能同时使用，所以我们需要将 ItemsSource 设置为 null，就可以避免这个报错了。\n除了这些，如果我们想要预览的是比较简单的数据，或者我们并不非常关心数据的内容及格式，只是希望生成几个项目从而查看样式或模板的书写是否有问题，那么还有一个更简单的方法：\n1 \u0026lt;ListBox ItemsSource=\u0026#34;{Binding Students}\u0026#34; d:ItemsSource=\u0026#34;{d:SampleData ItemCount=5}\u0026#34; /\u0026gt; 这样就可以生成 5 个虚拟的列表项了。\n更多功能 \u0026para; 除了上面介绍的这些，还有很多其他的设计时特性，比如：\nd:DesignSource 用于 CollectionViewSource 的设计时数据； DesignData 生成操作； 在其他程序集的自定义控件及附加属性上使用设计时特性。 关于上面的这些内容，大家可以移步我的视频观看倒数两个章节。\n参考 \u0026para; Design-Time Attributes Using Sample Data in the WPF Designer Use Design Time Data with the XAML Designer ","date":"2024-09-07T00:00:00Z","permalink":"https://blog.coldwind.top/posts/wpf-design-time-attributes/","title":"WPF 设计时特性的实用技巧"},{"content":"这次我们用于演示的 XML 文本来自 W3Schools 的一个样例，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;breakfast_menu\u0026gt; \u0026lt;food\u0026gt; \u0026lt;name\u0026gt;Belgian Waffles\u0026lt;/name\u0026gt; \u0026lt;price\u0026gt;$5.95\u0026lt;/price\u0026gt; \u0026lt;description\u0026gt;Two of our famous Belgian Waffles with plenty of real maple syrup\u0026lt;/description\u0026gt; \u0026lt;calories\u0026gt;650\u0026lt;/calories\u0026gt; \u0026lt;/food\u0026gt; \u0026lt;!-- 省略中间的三个 food --\u0026gt; \u0026lt;food\u0026gt; \u0026lt;name\u0026gt;Homestyle Breakfast\u0026lt;/name\u0026gt; \u0026lt;price\u0026gt;$6.95\u0026lt;/price\u0026gt; \u0026lt;description\u0026gt;Two eggs, bacon or sausage, toast, and our ever-popular hash browns\u0026lt;/description\u0026gt; \u0026lt;calories\u0026gt;950\u0026lt;/calories\u0026gt; \u0026lt;/food\u0026gt; \u0026lt;/breakfast_menu\u0026gt; 假定我们的任务是读取所有 food 节点的 name 属性的值，然后将它们存储到一个 List\u0026lt;string\u0026gt; 中。首先我们来用几种方式来实现这个需求。\n使用 XmlDocument \u0026para; XmlDocument 算是一种“传统”的方式。它有两种“玩法”，一种是使用诸如 GetElementsByTagName 这样的方法，一点一点地找到我们需要的节点及其属性和内容；另一种是使用 XPath 表达式，一次性找到所有符合条件的节点。我们先来看看第一种方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public List\u0026lt;string\u0026gt; XmlDocument() { var doc = new XmlDocument(); doc.LoadXml(testXml); return doc .GetElementsByTagName(\u0026#34;food\u0026#34;) .OfType\u0026lt;XmlNode\u0026gt;() .Select(node =\u0026gt; node[\u0026#34;name\u0026#34;]!.InnerText) .ToList(); // var names = new List\u0026lt;string\u0026gt;(); // foreach (XmlNode node in doc.GetElementsByTagName(\u0026#34;food\u0026#34;)) // { // names.Add(node[\u0026#34;name\u0026#34;]!.InnerText); // } // return names; } Info\r上面注释掉的代码是使用传统的 foreach 循环来实现的，这样写在旧版本的 .NET 中可能会更快一些，但是在 .NET 7 以来的新版本中，LINQ 的性能已经得到了很大的提升。对于常见的集合类型，LINQ 的性能已经和传统的 foreach 循环相差无几，甚至有时还更快，而且完全不会产生额外的 GC 压力。\r然后我们还可以用 XPath 表达式来实现：\n1 2 3 4 5 6 7 8 9 10 public List\u0026lt;string\u0026gt; XmlDocumentXPath() { var doc = new XmlDocument(); doc.LoadXml(testXml); return doc .SelectNodes(\u0026#34;//food/name\u0026#34;) .OfType\u0026lt;XmlNode\u0026gt;() .Select(node =\u0026gt; node.InnerText) .ToList(); } 使用 Xml.Linq \u0026para; Xml.Linq 是一种更加现代的方式，它的 API 设计更加友好，使用起来也更加方便。我们可以这样来实现：\n1 2 3 4 5 6 7 8 9 public List\u0026lt;string\u0026gt; XDocument() { var doc = XDocument.Parse(testXml); return doc .Root .Elements(\u0026#34;food\u0026#34;) .Select(node =\u0026gt; node.Element(\u0026#34;name\u0026#34;)!.Value) .ToList(); } XDocument 同样可以使用 XPath 表达式来实现，但是这里我们就不演示了，因为 XDocument 的 API 设计已经足够友好，不像是 XmlDocument 那样使用 XPath 表达式会显得更加简洁。\n使用 XmlReader \u0026para; XmlReader 是一种基于流的方式，它的操作并不简单，但是效率极高。我们可以这样来实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public List\u0026lt;string\u0026gt; XmlReader() { using var stringReader = new StringReader(testXml); using var xmlReader = System.Xml.XmlReader.Create(stringReader); var res = new List\u0026lt;string\u0026gt;(8); while (xmlReader.Read()) { if (xmlReader.IsStartElement() \u0026amp;\u0026amp; xmlReader.Name == \u0026#34;name\u0026#34;) { res.Add(xmlReader.ReadElementContentAsString()); } } return res; } 使用 Regex \u0026para; 因为我们的任务过于简单，要解析的 XML 文本内容也很纯粹，所以我们还可以使用正则表达式来实现：\n1 2 3 4 5 public List\u0026lt;string\u0026gt; Regex() { var matches = Regex.Matches(testXml, @\u0026#34;\u0026lt;name\u0026gt;(.*?)\u0026lt;/name\u0026gt;\u0026#34;); return matches.Select(match =\u0026gt; match.Groups[1].Value).ToList(); } 使用传统的字符串方法 \u0026para; 最后，我们还可以使用传统的字符串方法来实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public List\u0026lt;string\u0026gt; StringOps() { var res = new List\u0026lt;string\u0026gt;(8); int cur = 0; while (true) { // 找到下一个 \u0026lt;name\u0026gt; 节点 int idx = testXml.IndexOf(\u0026#34;\u0026lt;name\u0026gt;\u0026#34;, cur); // 如果找不到，说明已经找完了 if (idx \u0026lt; 0) break; // 找到对应的 \u0026lt;/name\u0026gt; 节点 int end = testXml.IndexOf(\u0026#34;\u0026lt;/name\u0026gt;\u0026#34;, idx + 6); res.Add(testXml.Substring(idx + 6, end - idx - 6)); // 从下一个节点开始继续找 cur = end + 7; } } 提前剧透一下，这个方式的效率非常低，远低于其他几种方式。因此，我们还有一个杀手锏：Span\u0026lt;T\u0026gt;。\n使用 Span \u0026para; Span\u0026lt;T\u0026gt; 是 C# 7.2 引入的一个新特性，它可以让我们更加高效地操作内存。我们可以这样来实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public List\u0026lt;string\u0026gt; SpanOps() { var res = new List\u0026lt;string\u0026gt;(8); var span = testXml.AsSpan(); while (true) { int idx = span.IndexOf(\u0026#34;\u0026lt;name\u0026gt;\u0026#34;); if (idx \u0026lt; 0) break; int end = span.Slice(idx + 6).IndexOf(\u0026#34;\u0026lt;/name\u0026gt;\u0026#34;) + idx + 6; res.Add(span.Slice(idx + 6, end - idx - 6).ToString()); span = span.Slice(end + 7); } return res; } 性能测试 \u0026para; 现在我们就可以来测试一下这几种方式的性能了。我们使用 BenchmarkDotNet 来进行测试。结果如下：\n怎么样，大家领教了 Span 的威力了吗？它一骑绝尘，已经进入纳秒的境界了。所以我们可以得出结论：\n如果我们要获取的内容并不复杂，我们完全可以使用正则表达式来抓取想要的内容，而不是死板地解析 XML 文档 当较为复杂时，我们还是需要借助传统的方式进行读取。它们的性能关系为：XmlReader \u0026gt; XDocument \u0026gt; XmlDocument 从实用性的角度考虑， XDocument 比 XmlReader 及 XmlDocument 都更加实用，速度比传统的 XmlDocument 快，又并不显著逊于 XmlReader，所以应该是我们在大多数情况下的最优选项 使用 Span 可以显著优化性能，尤其是我们需要频繁对字符串进行 IndexOf、SubString 等操作时 ","date":"2024-08-18T00:00:00Z","image":"https://s2.loli.net/2024/08/18/d1TnRLiG4kOu6j8.jpg","permalink":"https://blog.coldwind.top/posts/xml-read-benchmarks/","title":"如何高效读取 XML 中所需的内容（其一）"},{"content":" 本文有对应的视频教程：哔哩哔哩\n大家在做异步编程开发的时候，不知道是否会遇到这样的一种情形：\n有多个异步任务，这些任务之间没有依赖关系，但是我们需要等待所有任务都完成后再继续执行后续的操作。我们唯一知道的，就是这些任务的数量。\n举个例子：我们现在有三个 IO 相关的异步任务。这些任务的先后顺序是不确定的，并且这些任务也不必同时发起，但是我们需要等待这三个任务都完成后再继续执行后续的操作。\n对于最普通的等待多个异步任务，我们首先肯定会想到使用 Task.WhenAll 方法。但是 Task.WhenAll 现在并不能满足我们的需求，因为它需要能够立刻获取到所有任务的集合。并且因为我们希望在每个异步任务的中间某个环节去等待其他任务的完成，而并不是所有异步任务都会在同一时间点发起，所以这就产生了一个矛盾。\n这时候大家可能会想到另外一种更加简单粗暴的方式：我们创建一个局部字段 int count，然后每个异步任务完成后，我们将 count 自增。当 count 的值等于我们预期的任务数量时，我们就可以继续执行后续的操作。这种方式虽然可以解决问题，但是实现起来比较繁琐，因为我们还需要考虑使用什么机制来控制这些异步任务在 count 达到预期值时进行后续操作。最简单的方式无疑是使用轮询，但这显然是不够好的。聪明一些的方式是使用信号量，如 SemaphoreSlim，或者其他库提供的 AsyncAutoResetEvent 等。当然，我们还可以采用更加轻量的 TCS（TaskCompletionSource）来实现。但即便思路已经有了，实际实现起来依旧非常复杂，因为我们还要考虑 count 变量的线程安全、异常处理、取消任务等。\n引入 AsyncBarrier \u0026para; 这时候，AsyncBarrier 就派上用场了。AsyncBarrier 是一个非常轻量级的类，它可以帮助我们等待并同步多个异步任务。这个类是由 Microsoft.VisualStudio.Threading 提供的，我们可以轻易地找到它的源代码。\n实际在使用时，我并不推荐大家去直接将 Microsoft.VisualStudio.Threading 这个库引入到项目中，因为这个库本身是一个非常庞大的库，而且里面还包含了一些代码分析器（Code Analyzers），会给我们的项目添加一些恼人的“波浪线”。所以，一般情况下，我更推荐大家去使用 Nito.AsyncEx 这个库。但是它又不包含 AsyncBarrier 这个类，所以我们可以直接将 AsyncBarrier 的源代码复制到我们的项目中，然后稍作修改即可。如果你不想麻烦，我也提供了一个开箱即用的版本，在 GitHub Gist 上。\n我们来简单理解一下它的源代码。这里我节选了一部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public class AsyncBarrier { private readonly int participantCount; private readonly Stack\u0026lt;Waiter\u0026gt; waiters; public AsyncBarrier(int participants) { if (participants \u0026lt;= 0) throw new ArgumentOutOfRangeException( nameof(participants), $\u0026#34;Argument {nameof(participants)} must be a positive number.\u0026#34; ); this.participantCount = participants; this.waiters = new Stack\u0026lt;Waiter\u0026gt;(participants - 1); } public ValueTask SignalAndWait(CancellationToken cancellationToken) { lock (this.waiters) { if (this.waiters.Count + 1 == this.participantCount) { while (this.waiters.Count \u0026gt; 0) { Waiter waiter = this.waiters.Pop(); waiter.CompletionSource.TrySetResult(default); waiter.CancellationRegistration.Dispose(); } return new ValueTask( cancellationToken.IsCancellationRequested ? Task.FromCanceled(cancellationToken) : Task.CompletedTask ); } else { TaskCompletionSource\u0026lt;EmptyStruct\u0026gt; tcs = new(TaskCreationOptions.RunContinuationsAsynchronously); CancellationTokenRegistration ctr; if (cancellationToken.CanBeCanceled) { ctr = cancellationToken.Register( static (tcs, ct) =\u0026gt; ((TaskCompletionSource\u0026lt;EmptyStruct\u0026gt;)tcs!).TrySetCanceled(ct), tcs ); } else { ctr = default; } this.waiters.Push(new Waiter(tcs, ctr)); return new ValueTask(tcs.Task); } } } } 这里还有另外两个类型 Waiter 和 EmptyStruct，这里由于篇幅的关系就不展示了。它们做的事情也非常简单，前者用于存储等待器的信息，后者则是一个空结构体，用于表示一个空的异步操作。它们并不是我们的重点，所以就不展开讨论了。\n我们不难观察到这么几点：\n它内部有一个 participantCount 字段，表示参与者的数量；另外还有一个 Stack，用来存储所有等待的参与者； 它只有一个公开的方法 SignalAndWait，表示调用者现在要进入等待状态。在这个方法中： 首先，它会判断当前等待的参与者数量是否等于预期的参与者数量。如果是，那么就将等待器逐个从 Stack 中弹出并唤醒； 如果不是，那么就创建一个新的 TaskCompletionSource，并将其存入 Stack 中，然后返回这个 TaskCompletionSource 的 Task 给参与者用于 await。 当所有参与者都到齐后，SignalAndWait 方法会返回一个已完成的 ValueTask，这时候所有参与者都可以继续执行后续的操作。 Info\r这里其实还有一个小细节，就是 Stack 的容量是 participantCount - 1。这是因为我们并不需要将最后一个参与者也入栈。毕竟，当“倒数第一”到达终点时，我们就可以宣告比赛结束了。\r使用 AsyncBarrier \u0026para; 现在我们就可以来用一用它了。我们这里借助 CommunityToolkit.Mvvm 这个库来写一个视图模型（ViewModel），大致如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 partial class MainViewModel : ObservableObject { public ObservableCollection\u0026lt;string\u0026gt; Results { get; } = new(); private AsyncBarrier _asyncBarrier = new(3); [RelayCommand] async Task FirstJobAsync(CancellationToken token) { await Task.Delay(1500, token); Results.Add(\u0026#34;First job completed. Waiting for async barrier...\u0026#34;); await _asyncBarrier.SignalAndWait(token); Results.Add(\u0026#34;First job completed.\u0026#34;); } [RelayCommand] async Task SecondJobAsync(CancellationToken token) { await Task.Delay(1500, token); Results.Add(\u0026#34;Second job completed. Waiting for async barrier...\u0026#34;); await _asyncBarrier.SignalAndWait(token); Results.Add(\u0026#34;Second job completed.\u0026#34;); } [RelayCommand] async Task ThirdJobAsync(CancellationToken token) { await Task.Delay(1500, token); Results.Add(\u0026#34;Third job completed. Waiting for async barrier...\u0026#34;); await _asyncBarrier.SignalAndWait(token); Results.Add(\u0026#34;Third job completed.\u0026#34;); } } 这里我们定义了三个异步方法 FirstJobAsync、SecondJobAsync 和 ThirdJobAsync，它们分别模拟了三个异步任务。这三个任务之间没有依赖关系，但是我们希望在它们都完成后再继续执行后续的操作。我们在类中声明了一个 AsyncBarrier 字段，然后让这三个任务都调用它的 SignalAndWait 方法，这样就可以保证这三个任务都完成后才会继续执行后续的操作。\n实际运行代码，我们可以发现确实达到了我们想要实现的效果。这三个按钮可以让用户以任意的顺序及时间间隔进行点击，并且每个任务接近完成的时候，都会进入等待状态。只有当所有任务都完成后，我们才会看到所有任务都已完成的提示。\n更棒的是，AsyncBarrier 还可以重复使用。毕竟它底层只是一个 Stack。我们在等待时会入栈，等待完成后会出栈，最终使它回归初始状态。这样我们就可以在界面中反复实验这一现象。\n取消任务 \u0026para; 现在我们希望更进一步，为这些异步任务添加取消功能。那么，首先我们可以添加 InitAllJobs 与 FinishJobs 两个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private AsyncBarrier? _asyncBarrier; [MemberNotNull(nameof(_asyncBarrier))] // 提示编译器，这个方法会确保 _asyncBarrier 不为空 private void InitJobs() { if (_asyncBarrier == null) { _asyncBarrier = new AsyncBarrier(3); Results.Clear(); } } private void FinishJobs(bool success = true) { if (_asyncBarrier != null) { _asyncBarrier = null; if (success) Results.Add(\u0026#34;All jobs completed successfully.\u0026#34;); else Results.Add(\u0026#34;Jobs were canceled.\u0026#34;); } } 这两个方法分别用于初始化任务与结束任务。在初始化任务时，我们会创建一个新的 AsyncBarrier 实例，并清空 Results 集合。在结束任务时，我们会将 AsyncBarrier 实例置空，并根据是否成功完成任务来添加提示信息。\nTip\r这其实也是我比较推荐的使用 AsyncBarrier 的方式。虽然我们前面说了，它可以被重复使用。但是观察它的源代码会发现，它非常轻量，也不需要担心资源释放的问题，因为我们大可以每次使用的时候都实例化一个新的出来。毕竟这样还有一个好处，就是每次我们都可以根据实际情况去调整它的 participantCount。\r接下来我们就可以在每个异步任务中添加取消逻辑。以 FirstJobAsync 为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [RelayCommand] async Task FirstJobAsync(CancellationToken token) { InitJobs(); try { await Task.Delay(1200, token); Results.Add(\u0026#34;First job completed. Waiting for async barrier...\u0026#34;); await _asyncBarrier.SignalAndWait(token); FinishJobs(); } catch (TaskCanceledException) { Results.Add(\u0026#34;First job was canceled.\u0026#34;); FinishJobs(false); } } 这里的大致思路是：\n首先会调用 InitJobs 方法，初始化任务。这里每个异步方法都会尝试去初始化，但只有第一个（即 AsyncBarrier 字段为空时）是有效的； 在异步任务中使用 try-catch 块，捕获 TaskCanceledException 异常。因为如果我们想要取消任务，那么这个异步任务中的 Task.Delay 以及 AsyncBarrier.SignalAndWait 都会抛出这个异常； 当异步任务完成时，会调用 FinishJobs 方法，结束任务。并且这里类似 InitJobs，只有第一个异步任务会有效调用。 然后，我们还需要一个 RelayCommand，用来实现取消功能：\n1 2 3 4 5 6 7 [RelayCommand] private void CancelAllJobs() { if (FirstJobCommand.IsRunning) FirstJobCommand.Cancel(); if (SecondJobCommand.IsRunning) SecondJobCommand.Cancel(); if (ThirdJobCommand.IsRunning) ThirdJobCommand.Cancel(); } 这样我们就实现了想要的效果了。此时，我们在 XAML 中的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;Window ...\u0026gt; \u0026lt;Window.DataContext\u0026gt; \u0026lt;local:MainViewModel /\u0026gt; \u0026lt;/Window.DataContext\u0026gt; \u0026lt;DockPanel \u0026gt; \u0026lt;DockPanel DockPanel.Dock=\u0026#34;Bottom\u0026#34; LastChildFill=\u0026#34;False\u0026#34;\u0026gt; \u0026lt;Button Content=\u0026#34;Job1\u0026#34; Command=\u0026#34;{Binding FirstJobCommand}\u0026#34; /\u0026gt; \u0026lt;Button Content=\u0026#34;Job2\u0026#34; Command=\u0026#34;{Binding SecondJobCommand}\u0026#34; /\u0026gt; \u0026lt;Button Content=\u0026#34;Job3\u0026#34; Command=\u0026#34;{Binding ThirdJobCommand}\u0026#34; /\u0026gt; \u0026lt;Button Content=\u0026#34;Cancel\u0026#34; Command=\u0026#34;{Binding CancelAllJobsCommand}\u0026#34; DockPanel.Dock=\u0026#34;Right\u0026#34; /\u0026gt; \u0026lt;/DockPanel\u0026gt; \u0026lt;ListBox ItemsSource=\u0026#34;{Binding Results}\u0026#34; /\u0026gt; \u0026lt;/DockPanel\u0026gt; \u0026lt;/Window\u0026gt; 其实上面的故事还没有结束，因为实际运行后会发现，Cancel 按钮在任何时候都是可用的。这是因为我们没有正确处理它的 ICommand 的 CanExecute 方法。这里我就不展开讲了，我在视频中有详细讲解，大家可以在文章开头找到相应的视频链接。\n总结 \u0026para; AsyncBarrier 是一个非常轻量级的类，它可以帮助我们等待并同步多个异步任务。它的实现非常简单，但是却非常实用。我们可以在异步任务中使用它，来保证多个异步任务都完成后再继续执行后续的操作。同时，我们还可以在异步任务中添加取消逻辑，来保证任务的可靠性。\n大家如果有这样的需求，不妨去试一下这个类，相信一定可以帮上忙。不仅如此，我们还可以借此学习微软官方的源代码，了解一下它的实现细节。这对我们提升编程能力也是非常有帮助的。\n","date":"2024-08-11T00:00:00Z","image":"https://s2.loli.net/2024/08/11/15IEZJX7fCq4caS.jpg","permalink":"https://blog.coldwind.top/posts/use-asyncbarrier-to-sync-tasks/","title":"使用 AsyncBarrier 来等待并同步多个异步任务"},{"content":" 本文有对应的视频教程：哔哩哔哩\nC# 为字符串相关的操作提供了很多实用的类，比如：\nstring StringBuilder Encoding Regex 它们的功能相当强大，但这也导致了我们可能并不足够了解它，导致我们可能并不熟悉某些方法的重载，或者不知道某些方法的性能问题，最终导致我们的代码效率低下（而且我们还常常察觉不到）。这篇文章我将为大家介绍一些 C# 字符串操作的实用技巧和易犯错误，希望能帮助大家更好地使用字符串。\n在可以使用字符的时候不要使用字符串 \u0026para; 在 C# 中，声明一个字符与字符串，有一个很典型的区别，就是使用单引号和双引号。除此之外，它们二者也是区别很大的。字符串变量实际上是在堆上分配了一块内存空间，这个空间用来存储字符串的内容。而字符则是值类型，它存储在栈上，所以它的性能要比字符串要好很多。所以绝对不能把字符简单理解为长度为 1 的字符串，它们是完全不同的两种类型，效率也是很不相同的。\n在 C# 中使用 string 类型的某些方法时，我们就有机会使用字符而不是字符串，比如：\n1 2 3 4 5 6 7 string str = \u0026#34;Hello, World!\u0026#34;; str.StartsWith(\u0026#39;H\u0026#39;); str.EndsWith(\u0026#39;!\u0026#39;); str.Contains(\u0026#39;o\u0026#39;); str.IndexOf(\u0026#39;o\u0026#39;); str.Split(\u0026#39;,\u0026#39;); 这些方法都有重载，可以接受字符作为参数，这样我们就可以直接使用字符而不是字符串，这样可以提高代码的性能。\n为什么要这么做呢？除了上面提到的引用类型和值类型的区别以外，它们还有其他一些区别。以 Contains 为例，大家可以想象一下这个方法在底层是如何实现的。比如底层可能会是一个二层循环，第一层循环遍历字符串的每一个字符，第二层循环则在匹配到第一个字符后，再遍历后面的字符，看是否和我们要查找的子字符串相同。\n为了保证算法的通用性，即便我们传入的字符串长度为 1，底层也会把它当做一个字符串来处理。这对应到 JIT 编译后的机器码，就会有一些额外的开销，比如判断循环的跳出条件，以及跳转等。而如果我们传入的是字符，那么底层就可以直接比较单个字符的值，这样就可以减少一些额外的开销。\n使用方法的重载，减少不必要的调用 \u0026para; 字符串类的很多方法都包含了大量的重载。正确使用这些重载，有利于我们减少一些额外的调用，以及所造成的资源浪费。比如下面几个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 string str = \u0026#34; Hello, World,, Good, Morning \u0026#34;; // 这里我们希望将上面的内容按照逗号分割，并去除空字符串 // 正确的做法是使用下面这个 Split 方法的重载 var slices = str.Split(\u0026#39;,\u0026#39;, StringSplitOptions.RemoveEmptyEntries); //假如我们不知道这个重载，我们可能会写出下面这样的代码 var slices = str.Split(\u0026#39;,\u0026#39;).Where(s =\u0026gt; !string.IsNullOrEmpty(s)).ToArray(); // 还比如我们希望去除每个字符串的前后空格 // 正确的做法是使用下面这个 Split 方法的重载 var slices = str.Split(\u0026#39;,\u0026#39;, StringSplitOptions.TrimEntries); // 同样地，假如我们不知道这个重载，我们可能会写出下面这样的代码 var slices = str.Split(\u0026#39;,\u0026#39;).Select(s =\u0026gt; s.Trim()).ToArray(); 每一次对字符串类型调用它的常见方法，都会产生额外的开销。\n我们再来看另外一个例子：比较两个字符串是否相同。如果我们想要忽略大小写进行比较，我们可能会写出这样的代码：\n1 2 3 4 if (s1.ToLower() == s2.ToLower()) { // ... } 但是实际上，我们有效率显著高于上面这种方式的方法 Equals：\n1 2 3 4 if (s1.Equals(s2, StringComparison.OrdinalIgnoreCase)) { // ... } 是的，这个方法也拥有一些重载。这样我们就可以避免创建两个新的字符串，以及额外的比较操作。\nstring 类的构造函数 \u0026para; 相信大多数新手可能声明字符串的方式都是直接使用双引号，或者对其他字符串调用一些方法而得到，比如：\n1 2 3 string str = \u0026#34;Hello, World!\u0026#34;; string str2 = str.Substring(0, 5); string str3 = str.Replace(\u0026#34;,\u0026#34;, \u0026#34; \u0026#34;); 但实际上，string 类还有一些构造函数，可以帮助我们更好地创建字符串。相信用过 Python 的都知道，如果我们想在控制台输出一个长度为 20 个等号的分隔符，通常我们的做法是：\n1 print(\u0026#39;=\u0026#39; * 20) 其实在 C# 中，我们也可以实现类似的效果：\n1 2 string sep = new string(\u0026#39;=\u0026#39;, 20); Console.WriteLine(sep); 除此之外，如果我们有一个字符数组，我们也可以使用 string 类的构造函数来创建字符串。这个技巧一般用不到，可一旦我们有了一个需要转为字符串的字符数组，这个方法就会显得非常有用。一个典型的例子是，如果我们想翻转一个字符串，那么在不借助 Span 或 unsafe 的情况下，效率最高的方式为：\n1 2 3 char[] chars = str.ToCharArray(); Array.Reverse(chars); string reversed = new string(chars); 如果不知道字符串的构造函数的用法，可能就会写出下面的代码了：\n1 string reversed = string.Join(\u0026#34;\u0026#34;, str.Reverse()); 当然了，我们永远可以写出更加辣眼睛的代码，不是吗？\n1 2 3 4 // string reversed = new string(str.Reverse().ToArray()); char[] chars = str.Select(c =\u0026gt; c).ToArray(); chars = chars.Reverse().ToArray(); string reversed = string.Join(\u0026#34;\u0026#34;, chars); 与操作系统有关的一些方法 \u0026para; 由于 Windows 与 Unix 系统的一些区别，导致了两个时不常会让我们感到痛苦的事情：换行符和路径分隔符。在 Windows 系统中，换行符为 \\r\\n（CRLF），而在 Unix 系统中，换行符为 \\n（LF）。而路径分隔符在 Windows 系统中为 \\，而在 Unix 系统中为 /。\n在面对这些问题时，我们其实是有一些技巧的。比如处理路径时，我们可以使用 Path 类，它会根据当前操作系统的不同，返回不同的路径分隔符：\n1 2 3 4 5 var folder = \u0026#34;MyFolder\u0026#34;; var subfolder = \u0026#34;MySubFolder/\u0026#34;; var filename = \u0026#34;MyFile.txt\u0026#34;; var path = Path.Combine(folder, subfolder, filename); 这个方法不仅可以帮助我们处理路径分隔符，还可以帮助我们处理路径的拼接，以及路径的规范化。比如上面的例子中，subfolder 末尾多了一个 /，但是 Path.Combine 方法会自动帮我们去除这个多余的 /。\n类似地，面对换行符的问题，我们可以使用 Environment.NewLine 来获取当前操作系统的换行符。比如我们可以用下面的方式拼接一个多行字符串：\n1 2 3 4 5 6 7 var lines = new string[] { \u0026#34;Hello, World!\u0026#34;, \u0026#34;Good, Morning!\u0026#34; }; var text = string.Join(Environment.NewLine, lines); Tip\r类似 Environment.NewLine 这样的属性，我们还有 Path.DirectorySeparatorChar、Path.PathSeparator 等，它们都可以帮助我们处理一些与操作系统有关的问题。\r不仅如此，.NET 6 还为我们提供了一个新方法：ReplaceLineEndings。这个方法可以帮助我们将字符串中的换行符统一为当前操作系统的换行符：\n1 2 3 4 5 6 7 8 var text = \u0026#34;Hello, World!\\r\\nGood morning!\\nGood night!\u0026#34;; // 如果不传参，则默认将换行符替换为当前操作系统的换行符 var normalized = text.ReplaceLineEndings(); // 如果传入参数，则将换行符替换为指定的换行符 var normalized = text.ReplaceLineEndings(\u0026#34;\\n\u0026#34;); var normalized = text.ReplaceLineEndings(\u0026#34;\\t\u0026#34;); 其实很多时候，我们根本不需要显式地与换行符打交道。因为 .NET 的很多方法都会自动帮我们处理这些问题，比如：\n1 2 3 4 5 6 7 8 var lines = File.ReadAllLines(\u0026#34;file.txt\u0026#34;); File.WriteAllLines(\u0026#34;file.txt\u0026#34;, lines); Console.WriteLine(\u0026#34;...\u0026#34;); // 在控制台输出文本，并自动换行 Console.ReadLine(); // 读取用户输入，并自动处理换行符 var sb = new StringBuilder(); sb.AppendLine(\u0026#34;Hello, World!\u0026#34;); 等等。这些方法的名称中都会包含 Line 这个单词，大加可以多多留意。\nStringBuilder 的一些技巧 \u0026para; StringBuilder 可能是一个对于大家来说，既熟悉又陌生的类。熟悉是因为我们在处理大量字符串拼接时，都会用到它，陌生是因为我们可能并不了解它的所有功能。这里我就不多赘述了，我用一小段代码来展示 StringBuilder 的一些技巧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var sb = new StringBuilder(); // 添加字符串 sb.Append(\u0026#34;Hello, World!\u0026#34;); sb.AppendLine(\u0026#34;Hello, World!\u0026#34;); sb.AppendFormat(\u0026#34;Hello, {0}!\u0026#34;, \u0026#34;World\u0026#34;); sb.Append(\u0026#39;H\u0026#39;, 5); // 添加 5 个 \u0026#39;H\u0026#39; sb.Insert(0, \u0026#34;Hello, \u0026#34;); // 在指定位置插入字符串 sb.Replace(\u0026#34;Hello\u0026#34;, \u0026#34;Good\u0026#34;); // 替换字符串 sb.Remove(0, 5); // 删除指定位置的字符串 sb.Clear(); // 清空 StringBuilder sb.ToString(); // 将 StringBuilder 转为字符串 sb.ToString(0, 5); // 将 StringBuilder 的一部分转为字符串 没想到吧，连它的 ToString 方法都包含一个类似 SubString 的重载，方便我们减少一次不必要的内存开销。\n拥抱语法糖，使用字符串内插 \u0026para; 在 C# 6 中，我们迎来了字符串内插（String interpolation）这个语法糖。这个语法糖可以帮助我们更加方便地拼接字符串，而且还可以在字符串中插入表达式。比如：\n1 2 3 4 5 6 7 var name = \u0026#34;World\u0026#34;; var age = 18; var str = $\u0026#34;Hello, {name}! You are {age} years old.\u0026#34;; // 在以前，我们可能会写出下面这样的代码 var str = string.Format(\u0026#34;Hello, {0}! You are {1} years old.\u0026#34;, name, age); 实际上，这个语法糖的作用远不止于此，它的性能是高于 string.Format 的。甚至因为它性能的提升，我们在使用 StringBuilder 时，都可以考虑使用字符串内插来代替 AppendFormat。不过，对于这种情形，性能最高的方式是连续使用 Append 方法，形如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var id = 123; var name = \u0026#34;World\u0026#34;; var age = 18; var sb = new StringBuilder(); // 使用 AppendFormat sb.AppendFormat(\u0026#34;ID: {0}, Name: {1}, Age: {2}\u0026#34;, id, name, age); // 使用字符串内插 sb.Append($\u0026#34;ID: {id}, Name: {name}, Age: {age}\u0026#34;); // 使用连续的 Append 方法 sb.Append(\u0026#34;ID: \u0026#34;).Append(id).Append(\u0026#34;, Name: \u0026#34;).Append(name).Append(\u0026#34;, Age: \u0026#34;).Append(age); 总结 \u0026para; 除此之外，字符串还有很多技巧，比如：\n原始字符串（Raw string） StringPool 与 string.Intern Span\u0026lt;char\u0026gt; 文本编码（Encoding） 一些与字符串有关的特性 但是因为篇幅的关系，我们这次就不展开了。希望大家能够通过这篇文章，了解到一些 C# 字符串操作的实用技巧和易犯错误。希望大家在以后的开发中，能够更加熟练地使用字符串，写出更加高效的代码。\n","date":"2024-07-27T00:00:00Z","image":"https://s2.loli.net/2024/07/29/nzM6Ya8AJDZNlhi.jpg","permalink":"https://blog.coldwind.top/posts/csharp-string-tips-tricks/","title":"C# 字符串操作实用技巧及新手易犯错误"},{"content":"INI 文件是一种相当古老的配置文件格式，但很“可惜”的是，它如今依旧被广泛使用。正因为如此，即便现在已经出现了很多更加现代化的配置文件格式（比如 JSON、YAML、TOML 等），我们仍然可能会遇到读写 INI 文件的情形。那么这次我们就来看看如何在 C# 中读写 INI 文件。\nINI 文件格式概述 \u0026para; INI 文件是一种文本文件，它由一系列的节（Section）和键值对（Key-value pair）组成。每个键值对都位于某个节中，键和值位于等号（=）左右，而节则由方括号（[]）括起来。一个简单的 INI 文件看起来可能是这样的：\n1 2 3 4 5 6 7 [Section1] Key1=Value1 Key2=Value2 [Section2] Key3=Value3 Key4=Value4 此外，INI 文件还支持注释，通常以分号（;）开头（有时也可以自定义为其他符号，比如 # 等），直到行尾为止：\n1 2 [Section1] Key1=Value1 ; 这是一个注释 INI 文件的格式要求基本就是这样了。其他可能还有一些诸如命名习惯，以及等号左右是否添加空格等细节，但这些通常都是没有具体约束的。\n不难发现，INI 因为格式极其简单，所以它的解析也是相当容易的，我们稍加思考，通常就可以写出一个简单的解析器。但是，既然已经有现成的解析库，我们当然不必自己重复造轮子。接下来我们就来看看在 C# 中如何读写 INI 文件。\n传统方法：使用 Win32 API \u0026para; 相信大家只要在网上搜索过这个问题，就一定会看到有人推荐使用 Win32 API 来读写 INI 文件。这种方法的优点是简单、高效，但缺点也很明显：它是不跨平台的。如果你的程序需要在 Linux 或 macOS 上运行，那么这种方法就不适用了。\nINI 文件的读写操作在 Windows 平台上有专门的 API 支持，这些 API 位于 kernel32.dll 中。我们可以通过 P/Invoke 的方式调用这些 API，实现对 INI 文件的读写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 using System; using System.Runtime.InteropServices; [DllImport(\u0026#34;kernel32\u0026#34;)] private static extern long WritePrivateProfileString(string section, string key, string val, string filePath); [DllImport(\u0026#34;kernel32\u0026#34;)] private static extern int GetPrivateProfileString(string section, string key, string def, StringBuilder retVal, int size, string filePath); public string IniReadValue(string Section,string Key) { StringBuilder temp = new StringBuilder(256); int i = GetPrivateProfileString(Section,Key,\u0026#34;\u0026#34;,temp, 256, this.path); return temp.ToString(); } 我们只需要从 kernel32.dll 中导入 WritePrivateProfileString 和 GetPrivateProfileString 两个函数，就可以实现对于 INI 文件的读写操作了。通常情况下，我们还会额外写一个 IniReadValue 方法来包装 GetPrivateProfileString 函数，以便更加方便地读取键值。\nInfo\r除了上面的两个方法，kernel32.dll 中还有一些其他的函数，比如 GetPrivateProfileSection、GetPrivateProfileSectionNames 等，它们可以帮助我们更加方便地操作 INI 文件。有兴趣的读者可以自行查阅相关文档。\r但是大家在使用这个库的时候，不知道会不会有一种仿佛“高射炮打蚊子”一样的心情？毕竟 INI 这么简单的一种格式，居然要使用到 P/Invoke 来调用 Win32 API，这未免也太麻烦了。所以，这种传统方式存在以下问题：\n使用体验差：需要通过 P/Invoke 来调用 Win32 API，这对于 C# 开发者来说并不是一种友好的体验。 不跨平台：这种方法只能在 Windows 平台上使用，无法在 Linux 或 macOS 上运行。 线程不安全：由于这是一个全局函数，每次调用都会操作外部文件，所以在多线程环境下可能会出现问题。 时间复杂度高：假如我们想要读取 INI 文件中的多个键值对，那么就需要多次调用 GetPrivateProfileString 函数，而每次调用都需要从文件开头开始读取，直到找到对应的键值对。这样的时间复杂度显然是不够理想的。 文本编码：这种方法只会使用系统默认的文本编码（比如中文操作系统的 ANSI 对应 GBK 编码），无法指定其他编码，因此非 ASCII 字符可能会出现乱码。 所以下面我们再介绍几个别的库。但是大家也不要高兴太早，因为这些库虽然各有优点，但也有各自的问题。\n第三方库：Ini-Parser \u0026para; ini-parser 是一款非常好用的 INI 文件解析库。它可以一次性将整个 INI 文件解析为一个 IniData 对象（可以想象成一个字典），从而方便我们像操作字典那样便捷又高效地进行高频率的读写操作，并在最后统一写回文件。\nTip\r大家在 NuGet 中搜索 ini-parser 时，还会发现 ini-parser-netstandard 这个库。这两个库的功能是一样的，只是前者是 .NET Framework的，而后者则是 .NET Standard 2.0 的，因此可以在 .NET Core、.NET 5+ 及跨平台环境中使用，甚至还可以用于 Unity 游戏开发。推荐大家在任何情况下都使用后者。\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 using IniParser; var parser = new FileIniDataParser(); IniData data = parser.ReadFile(\u0026#34;config.ini\u0026#34;); // 读取键值对 string value1 = data[\u0026#34;Section1\u0026#34;][\u0026#34;Key1\u0026#34;]; string value2 = data[\u0026#34;Section1\u0026#34;][\u0026#34;Key2\u0026#34;]; // 修改键值对 data[\u0026#34;Section1\u0026#34;][\u0026#34;Key1\u0026#34;] = \u0026#34;NewValue1\u0026#34;; data[\u0026#34;Section1\u0026#34;][\u0026#34;Key2\u0026#34;] = \u0026#34;NewValue2\u0026#34;; // 写回文件 parser.WriteFile(\u0026#34;config.ini\u0026#34;, data); 除此之外，它还支持更多功能，比如合并多个 INI 文件等。大家可以查看官方文档来了解更多信息。\n但是，这个库有一个非常明显的限制：虽然它一次性读取了整个 INI 文件，使得我们在需要频繁读写时更加高效。但是当文件较大时，一次性读取整个文件可能会导致占用更大的内存；不仅如此，如果我们的需求仅仅是临时读写某一项配置，那么这种一次性读取整个文件的方式显然是不够高效的。\n所以这里再和大家推荐另外一个库。\n第三方库：IniSharp \u0026para; IniSharp 真是一个不错的名字。这个库提供了便捷的操作 INI 文件的方法，并且不依赖 Win32 API，因此可以在跨平台环境下使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 using IniSharp; var ini = new IniFile(\u0026#34;config.ini\u0026#34;, Encoding.UTF8); var value1 = ini.GetValue(\u0026#34;Section1\u0026#34;, \u0026#34;Key1\u0026#34;); var value2 = ini.GetValue(\u0026#34;Section1\u0026#34;, \u0026#34;Key2\u0026#34;, \u0026#34;Default\u0026#34;); // 如果该键不存在，则创建并返回默认值 ini.SetValue(\u0026#34;Section1\u0026#34;, \u0026#34;Key1\u0026#34;, \u0026#34;NewValue1\u0026#34;); ini.DeleteKey(\u0026#34;Section1\u0026#34;, \u0026#34;Key2\u0026#34;); ini.DeleteSection(\u0026#34;Section2\u0026#34;); List\u0026lt;string\u0026gt; sections = ini.GetSections(); List\u0026lt;string\u0026gt; keys = ini.GetKeys(\u0026#34;Section1\u0026#34;); 这个库并不会一次性读取整个 INI 文件，而是在每次操作时进行读取或写入操作，因此不会占用过多的内存。这在我们的需求是临时读写某一项配置时显得尤为重要。\n但是我仍然要泼大家一盆冷水：这个库的性能并不高，因为它底层的代码存在一些值得优化的空间。以读取单个键值的方法为例（以下代码为节选，并不完整）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 它在底层声明了一个“碰巧”与 Win 32 API 一样的函数名 private string GetPrivateProfileString(string section, string key, string defaultValue = null) { List\u0026lt;string\u0026gt; lines = File.ReadAllLines(filePath, FileEncoding).ToList(); (int sectionNum, int keyNum) = FindSectionAndKey(section, key, lines); if (sectionNum != -1 \u0026amp;\u0026amp; keyNum != -1) { int startIndex = lines[keyNum].IndexOf(key); int equalsIndex = lines[keyNum].IndexOf(\u0026#39;=\u0026#39;, startIndex + key.Length); string strLalue = lines[keyNum].Substring(equalsIndex + 1); int hashIndex = strLalue.IndexOf(commentChar); return (hashIndex != -1) ? strLalue.Substring(0, hashIndex) : strLalue; } if (defaultValue != null) { if (sectionNum != -1) { if (keyNum == -1) { lines.Insert(sectionNum + 1, $\u0026#34;{key}={defaultValue}\u0026#34;); lock (lockObject) { File.WriteAllLines(filePath, lines, FileEncoding); } } } else { lock (lockObject) { using (StreamWriter sw = File.AppendText(filePath)) { sw.WriteLine($\u0026#34;[{section}]\u0026#34;); sw.WriteLine($\u0026#34;{key}={defaultValue}\u0026#34;); } } } } return defaultValue; } 不难看出几个问题：\n它使用的是 ReadAllLines() 方法，而不是采用 ReadLines() 方法返回一个延迟加载的 IEnumerable\u0026lt;string\u0026gt;，或使用 StreamReader 逐行读取。这样会导致一次性读取整个文件，占用更多内存。尤其是即便我们要找的键就在文件的开头，它也会从头读取整个文件，这显然是不够高效的。 它使用了 File.WriteAllLines() 方法，每次修改都会重写整个文件。 在插入新键值对时，它使用了 List.Insert() 方法，这会导致整个列表的元素向后移动，时间复杂度为 O(n)。 除此之外，这个库还有其他一些提升空间，比如可以使用 Span、ArrayPool 等，来减少内存分配和 GC 压力。\n总结 \u0026para; 上面提到的几种方式可以说是各有千秋，总会存在一些缺憾，因此关于 INI 这么简单的一个文件格式，我们的故事并没有结束。在后续的文章中，我还会和大家分享更多关于 INI 文件的读写方法，以及一些优化技巧。欢迎大家继续关注我的博客。\n","date":"2024-07-11T00:00:00Z","image":"https://s2.loli.net/2024/07/11/QyFiMdrfNPKpazT.jpg","permalink":"https://blog.coldwind.top/posts/deal-with-ini-file/","title":"如何读写 INI 配置文件？"},{"content":" 本文有对应的视频教程：哔哩哔哩\n在写 C# 代码的时候，我们经常会写诸如此类的自动属性：\n1 2 3 4 public Person { public int Age { get; set; } } 这时候相信很多人都会有疑问：为什么我们要费劲写成这样的自动属性？为什么不能直接简单地把它写成一个公共字段呢？就比如这样：\n1 2 3 4 public Person { public int Age; } 其实这是有一些原因的。我们这次就来探讨一下。\n看待属性与字段的方式不同 \u0026para; 首先最重要的，就是我们看待属性与字段的方式，或者对于它们所扮演的角色的理解是不一样的。\n当我们看到一个属性时，通常我们都会期望它拥有一个公共的读权限，同时拥有一个可能不公开的写权限还可能在初始化上存在一些限制。通常我们写一个属性时，都是希望它存在被外界访问的价值，并且我们也充分考虑了后果（比如我们可以在 setter 中添加逻辑，或干脆不开放 setter）。\n也就是说，通常情况下我们希望一个属性它是一个：\n（一般情况下）可以在类外被访问到，并且具有一定的意义，是开发者故意暴露出来的成员 它的初始化可能包含一些逻辑，比如可以在什么时候被初始化，是否必须被初始化，初始化后还能否更改等 它后台未必一定对应一个字段，而是会通过一些方式来得到它的值 Info\r对于第 3 条，我可以举出一些例子：\nList.Count 实际与底层的 Array 的长度有关 AsyncRelayCommand.IsRunning 与底层的 Task 的状态有关 ObservableValidator.HasErrors 与底层用于存放错误信息的列表有关 CheckBox.IsChecked 与底层的依赖属性有关 但是当我们看到字段时，通常会怎么考虑呢？我们先来看一段简单的代码：\n1 2 3 4 5 6 7 class Manager { private readonly int _uniqueId; // 一个可能有特殊作用的唯一 ID private readonly IConfiguration _config; // 一个通过依赖注入的方式在构造中初始化的接口对象 private bool _flag = false; // 一个只用于内部方法间传递状态的标志位 private readonly object _syncRoot = new(); // 一个只用于类内部的线程锁 } 大家对于字段的印象是否一般都是这样的呢？如果是的话，那么相信在看到下面的代码时，一定会有点恍惚和不知所措吧：\n1 2 3 4 5 6 class Manager { protected readonly int UniqueId; public bool Flag = false; public string ErrorMessage = \u0026#34;Oops!\u0026#34;; } 所以这里面的道理相信大家应该已经有一定感觉了。是的，我们通常对于字段所扮演角色的理解是：\n它通常只用于类内，作为其他属性或方法的辅助角色（比如线程锁、标志位、依赖注入的对象等） 它通常不包含太多的逻辑，只是一个简单的值，而且也不如属性那样具有多种初始化的方式 它通常不太“安全”，或者说开发者在不了解的情况下不太敢轻易去操作它 基于这样不同的看待方式，相信大家应该都能理解为什么我们一般不直接使用公共字段了。\n当然了，例外情况肯定也是有的。比如说我们在开发一个简单的 Unity 游戏，那么通常我们会写出这样的代码：\n1 2 3 4 5 6 7 public class Player : MonoBehaviour { [SerializeField] private int health; // Unity 官方推荐的命名习惯是首字母小写 public int attack; public int defense; } 或者当我们想要与 C/C++ 写的 DLL 交互时，我们可能会写出这样的代码：\n1 2 3 4 5 6 7 [StructLayout(LayoutKind.Sequential)] public struct MyData { public ushort Index; public uint Value; public byte[] Data; } 这些情况下，我们可能会直接使用公共字段，而不是属性。\n长期的约定俗成 \u0026para; 既然我们有这样不同的看待方式，所以就出现了相当多类似的开发习惯，甚至连标准库及第三方库也在有意无意贯彻着这样的习惯。\nInfo\r当然了，这里面其实还有一个“先有鸡还是先有蛋”的问题。也就是说，我们是因为有了这样的习惯，所以才会有这样的标准库设计，还是因为标准库设计的如此，所以我们才会有这样的习惯呢？不过这个问题就不在我们的讨论范围内了。\r这里我可以举很多例子：\n在 WPF 开发中，如果你想在 XAML 中绑定一个类（通常为 Model 或 ViewModel）的变量，那么这个变量必须是一个属性，而不能是一个字段。此外，WPF 中另一个相当重要的功能——依赖属性——也会充分和属性打交道。 在进行类的序列化与反序列化时，Json.NET、System.Text.Json 等库默认只会序列化属性，而不会序列化字段。 DataGrid、PropertyGrid 等会根据数据类型来自动生成界面的控件都是关注属性而非字段。 在 EntityFramework Core 中，如果你想要使用代码优先（Code-First）的方式，那么你的实体类中的属性必须是属性，而不能是字段；而使用数据库优先（Database-First）的方式时，工具自动生成的也是属性。 C# 的接口可以包含属性，但不能包含字段。 C# 的记录类（record）底层也是使用属性来实现的。 其他还有一些别的例子，比如我们在使用数据映射的工具（如 Mapster、AutoMapper 等）时，可能也会发现属性和字段的一些不同之处。\n所以，既然这样的习惯广泛存在，我们为什么要选择做一个另类的开发者呢？\n灵活性与封装性 \u0026para; 属性具有无与伦比的灵活性。我们可以在属性的 getter 和 setter 中添加任意的逻辑，比如数据校验：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Person { private int _age; public int Age { get =\u0026gt; _age; set { if (value \u0026lt; 0) { throw new ArgumentOutOfRangeException(nameof(value), \u0026#34;Age must be greater than 0.\u0026#34;); } _age = value; } } } 再比如通知功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ViewModel : INotifyPropertyChanged { private string _name; public string Name { get =\u0026gt; _name; set { if (_name != value) { _name = value; OnPropertyChanged(nameof(Name)); // 事件与方法的实现略 } } } } 但更重要的是它的封装性。比如常见的 setter 就有这么几种：\npublic：公共的 setter，任何人都可以修改这个属性 protected：受保护的 setter，只有继承这个类的子类才能修改这个属性 private：私有的 setter，只有这个类内部的方法才能修改这个属性 internal：内部的 setter，只有同一个程序集内的方法才能修改这个属性 init：初始化 setter，只能在构造函数中初始化这个属性 空：只读属性，只能在构造函数中初始化这个属性 不仅如此，还可以配合诸如 required、virtual 等关键字，使得属性的灵活性和封装性更上一层楼。这些都是字段完全无法比拟的（我知道上面的一些关键字也可以用于字段，但效果都很有限，比如会同时限制读写的权限等）。\n性能方面的考虑 \u0026para; 这时候可能有同学又要说了：我知道自动属性其实是个语法糖，最终还是会被编译器转换成字段和方法，形如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Person { [CompilerGenerated] private int \u0026lt;Age\u0026gt;k__BackingField; public int Age { [CompilerGenerated] get { return \u0026lt;Age\u0026gt;k__BackingField; } [CompilerGenerated] set { \u0026lt;Age\u0026gt;k__BackingField = value; } } } 那么调用方法去读写字段的值，效率上理应比直接读写字段要低对吧？如果是这样的话，把 { get; set; } 这样的自动属性直接写成公共字段，不是更好吗？\n这是个好问题，我们来看这样一个例子。下面的 Person 类中，我们定义了两个属性，一个是自动属性，一个是字段：\n1 2 3 4 5 6 7 8 9 10 var p = new Person(); p.Age1 = 10; p.Age2 = 20; public class Person { public int Age1 { get; set; } public int Age2; } 如果我们观察 IL 代码，会发现：\n1 2 3 4 5 6 7 IL_0000: newobj instance void Person::.ctor() IL_0005: dup IL_0006: ldc.i4.s 10 IL_0008: callvirt instance void Person::set_Age1(int32) IL_000d: ldc.i4.s 20 IL_000f: stfld int32 Person::Age2 IL_0014: ret 好像确实不大对劲啊。Age1 就是使用了 Person::set_Age1 方法，而 Age2 却直接使用了 stfld 指令。那是不是说明修改属性的速度就是会略微慢于直接修改字段呢？先别急，我们再来看一看 JIT 编译后的代码：\n1 2 3 4 5 6 Program.\u0026lt;Main\u0026gt;$(System.String[]) L0000: mov ecx, 0x33a4ca1c L0005: call 0x066f300c L000a: mov dword ptr [eax+4], 0xa L0011: mov dword ptr [eax+8], 0x14 L0018: ret 这里我们可以看到，自动属性的 setter 其实会被 JIT 编译器优化成直接的内存写入操作。这就意味着，实际上在运行时，修改属性和直接修改字段的速度是一样的。所以，自动属性的性能和公共字段是完全一样的。大家大可以打消这个顾虑了。\n.NET 9 即将到来的新语法特性 \u0026para; 如果你还在犹豫的话，我还可以再告诉你一个好消息：.NET 9（C# 13）即将引入一个新语法特性：field 关键字（这个关键字曾经在 C# 11 的时候就释放过信号，但因为一些原因姗姗来迟）。这个新特性可以让你更加方便地声明一个属性。\n我们都知道，以前我们写完整属性（propfull）时，需要写成这样：\n1 2 3 4 5 6 7 private int _age; public int Age { get =\u0026gt; _age / 2; set =\u0026gt; _age = value * 2; } 但是现在，有了 field 关键字，我们可以这样写：\n1 2 3 4 5 public int Age { get =\u0026gt; field / 2; set =\u0026gt; field = value * 2; } 这里的 field 就相当于那个 _age 字段。这样一来，我们就可以更加方便地声明一个属性了。\n总结 \u0026para; 通过上面的讨论，相信大家对于为什么我们一般不使用公共字段，而是选择自动属性有了更深的理解。当然了，这并不是说我们就不能使用公共字段了。在一些特殊的场景下，我们还是可以使用公共字段的。但是在大多数情况下，我们还是应该选择自动属性。\nC# 后面不断新增的语法特性，一直在优化我们使用属性的体验。在比较旧的 C# 版本中，我们甚至不能给自动属性直接赋值，而是需要通过构造函数来初始化。但是随着 C# 版本的不断更新，我们可以看到，自动属性的使用变得越来越方便了。除了上面提到的即将到来地 field 关键字，我们在 C# 9 还迎来了记录类型，在 C# 12 又迎来了主构造函数。这些都是为了让我们更加方便地使用属性。\n相信大家今后可以更加无忧无虑地使用属性。\n","date":"2024-06-13T00:00:00Z","image":"https://s2.loli.net/2024/06/13/6rLfG3dzciJpjvO.jpg","permalink":"https://blog.coldwind.top/posts/why-we-prefer-property-over-field/","title":"为什么我们一般不使用公共字段，而是选择自动属性？"},{"content":" 本文有对应的视频教程：哔哩哔哩\nGo 中的 defer 大概是怎么一回事 \u0026para; Go 语言中有一个非常好用的 defer 关键字。defer 会在函数返回之前执行，可以用来释放资源，关闭文件等。比如我们想打开并读取一个外部文件的内容，我们可以这样写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func ReadFile() { file, err := os.Open(\u0026#34;file.txt\u0026#34;) // 如果打开文件失败，直接返回 if err != nil { log.Fatal(err) } // 在函数返回之前关闭文件 defer file.Close() // 读取文件内容 content := make([]byte, 1024) file.Read(content) fmt.Println(string(content)) } 在这个例子中，我们使用 defer 关键字来确保在函数返回之前关闭文件。这样我们就不用担心忘记关闭文件，导致资源泄漏。\n其实在 C# 和 Python 中，我们也可以借助一些特殊的语法来实现类似的效果。比如在 C# 中，我们可以使用 using 关键字来确保资源在使用完之后被释放；在 Python 中，我们可以使用 with 关键字来确保资源在使用完之后被释放。\n但有些时候，我们想要实现的功能只是希望在离开作用域之前执行一些代码，而不是释放资源。这种情况下，我们仍然可以借助 using 关键字来实现，可以为我们带来意想不到的便利。\n在 C# 中模拟 Go 的 defer \u0026para; 前面已经提到，我们需要在 C# 中使用 using 关键字来模拟 Go 的 defer。但是 using 关键字只能用于“释放资源”，或者说需要对一个实现了 IDisposable 接口的对象进行操作。那么我们就必须实现 Dispose 相关的逻辑了。话虽如此，并没有人规定我们必须在 Dispose 方法中执行释放资源的逻辑。比如我们前面提到的，希望在离开作用域之前执行一些代码，就可以放在 Dispose 方法中去执行。\n基于这个思路，我们可以写出这样的代码：\n1 2 3 4 5 6 7 8 9 10 11 public class MyDisposable : IDisposable { private readonly Action _callback; public MyDisposable(Action callback) { _this._callback = callback; } public void Dispose() =\u0026gt; _callback(); } 这样我们就可以在 Dispose 方法中执行我们想要执行的代码了。比如我们可以这样使用：\n1 2 3 4 5 6 void Foo() { using var md = new MyDisposable(() =\u0026gt; Console.WriteLine(\u0026#34;Job is done.\u0026#34;)); // Do something } 我们在上面的例子中还用到了 C# 8.0 的新特性：using 语法的改进。在 C# 8.0 中，我们可以省略 using 语句中的大括号，直接在 using 语句后面写一个表达式。这样我们就可以更加简洁地使用 using 语法了。\n它实际对应的底层 C# 代码是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void Foo() { MyDisposable md = new MyDisposable(() =\u0026gt; Console.WriteLine(\u0026#34;Job is done.\u0026#34;)); try { // Do something } finally { if (md != null) { md.Dispose(); } } } 所以可以保证 finally 语句中的代码一定会被执行，即使在 try 语句中抛出了异常。\n这一技巧在 WPF 开发中的妙用 \u0026para; 其实这个小妙招并不是我的原创，而是油管上的 Jason Williams 在他的一期视频中提到的。在他的视频中，他为我们提供了一个绝妙的点子。\n我们在做 WPF（以及其他诸如 Win UI、Avalonia 等）的客户端开发时，经常会遇到一个问题，就是需要去管理一个进度条的可见状态。比如我们现在有一个异步任务，我们希望任务在执行期间能够显示一个进度条，任务执行完毕（不管成功与否）后进度条消失。通常我们的做法是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 模拟搜索电影的异步任务 public bool IsBusy { get; set; } = false; // 控制进度条是否可见，且该属性具备通知功能 async Task SearchMovieAsync(string movieName) { IsBusy = true; if (!CanSearch()) { IsBusy = false; return; } var resList = await SearchMoviesFromInternetAsync(movieName); if (resList == null || resList.Count == 0) { IsBusy = false; return; } foreach (var res in resList) { // Do something } IsBusy = false; } 可以看到，我们在方法中需要多次根据情况设置 IsBusy 属性。这样的代码看起来不太优雅。为了解决这个问题，我们就可以用上前面实现的类了。不过我们需要稍微修改一下，使它的回调函数可以接受一个参数：\n1 2 3 4 5 6 7 8 9 10 11 12 public class BusyDisposable : IDisposable { private readonly Action\u0026lt;bool\u0026gt; _busySetter; public BusyDisposable(Action\u0026lt;bool\u0026gt; busySetter) { _busySetter = busySetter; _busySetter(true); } public void Dispose() =\u0026gt; _busySetter(false); } 然后我们就可以这样使用了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 async Task SearchMovieAsync(string movieName) { using var _ = new BusyDisposable(value =\u0026gt; IsBusy = value); if (!CanSearch()) { return; } var resList = await SearchMoviesFromInternetAsync(movieName); if (resList == null || resList.Count == 0) { return; } foreach (var res in resList) { // Do something } } Info\r这里有一个需要注意的点：我们是在 ViewModel 中对 IsBusy 进行的操作，并借助绑定来控制前台进度条的显示。这无形中帮助我们解决了一个重要的隐患：线程安全。即便我们在非 UI 线程中修改了 IsBusy 属性，由于 WPF 的数据绑定机制，我们也不用担心线程安全问题。\n但如果是在 View 中去直接操作进度条的 Visibility 属性，那么就可能需要我们自己去处理线程安全问题了。常见的方式比如使用 Dispatcher，或参考我的这篇 关于使用 IProgress 的文章。\n相信大家立刻就能够明白这个方式有多么简洁和优雅了。我们通过使用 using 关键字，保证了当前作用域中的代码不管是正常执行还是异常退出，都会在离开作用域之前执行 IsBusy = false 这一行代码。这样我们就不用在方法中多次设置 IsBusy 属性了。\n甚至我们还能再稍微优化一下，比如使用一个自动属性来简化 BusyDisposable 的实例化：\n1 2 3 4 5 6 7 8 9 private BusyDisposable NewBusyDisposable =\u0026gt; new BusyDisposable(value =\u0026gt; IsBusy = value); async Task SearchMovieAsync(string movieName) { using var _ = NewBusyDisposable; // ... } 这样我们就可以进一步简化这一语法，从而使其更接近 Go 语言中的 defer 关键字的使用方式。\n总结 \u0026para; 本期内容主要介绍了 Go 语言中的 defer 关键字，以及如何在 C# 中模拟 defer 的实现。虽然我们似乎一定程度上“滥用”了 using 关键字以及 IDisposable 接口，但这种方式确实可以带来一些意想不到的便利。\n油管上的这位 Jason Williams 也绝对是一位大神。虽然他视频非常少，粉丝也只有几百，但是每期内容都堪称精品。大家有机会的话也可以去关注一下他，相信一定会有所收获。\n","date":"2024-05-28T00:00:00Z","image":"https://s2.loli.net/2024/05/28/WyuKtqiXZQ3pDEA.jpg","permalink":"https://blog.coldwind.top/posts/mimic-go-defer-in-csharp/","title":"如何在 C# 中模拟 Go 的 defer 关键字并用于客户端开发"},{"content":" 本文有对应的视频教程：哔哩哔哩\n在执行异步任务时，有时候我们会希望有办法汇报进度。比如在一个 WPF 程序中，我们在界面上放了一个进度条，从而展示当前任务的进度。那么该如何汇报异步任务的进度呢？\n其实 .NET 标准库就为我们提供了实现这一功能的接口和类：IProgress\u0026lt;T\u0026gt; 与 Progress\u0026lt;T\u0026gt;，其中 T 是一个泛型类型，表示要汇报的内容。如果我们希望汇报一个百分比进度，那么使用 double 类型即可；类似地，如果我们希望汇报一些更加复杂的内容，还可以使用 string 甚至一些自定义类与结构体。\n下面我们就来看看该如何使用吧。\n搭建项目 \u0026para; 首先我们创建一个简易的 WPF 项目。因为这次的任务比较简单，所以我们就不遵循 MVVM 模式了，而是使用最传统的 WPF 事件注册的方式。\n它的 MainWindow 形如：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;Window ...\u0026gt; \u0026lt;StackPanel VerticalAlignment=\u0026#34;Center\u0026#34;\u0026gt; \u0026lt;Button Width=\u0026#34;100\u0026#34; Margin=\u0026#34;0,0,0,10\u0026#34; Content=\u0026#34;Run\u0026#34; Click=\u0026#34;Button_Click\u0026#34; /\u0026gt; \u0026lt;ProgressBar Height=\u0026#34;20\u0026#34; d:Value=\u0026#34;10\u0026#34; Name=\u0026#34;progressBar\u0026#34; /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;/Window\u0026gt; 然后在 MainWindow.xaml.cs 中实现一些简单的逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } private async void Button_Click(object sender, RoutedEventArgs e) { await DoJobAsync(CancellationToken.None); } async Task DoJobAsync(CancellationToken token) { if (token.IsCancellationRequested) return; for (int i = 0; i \u0026lt; 100; i++) { await Task.Delay(50, token); progressBar.Value = i + 1; if (token.IsCancellationRequested) { break; } } } } 我们将按钮注册的 Button_Click 方法修改为 async void，这样我们就可以在里面等待一个异步任务了。\nInfo\r虽然 async void 是一种非常危险的方式，但因为 Button 控件的 Click 事件对应委托对于函数传参及返回值的限制，这里我们不得不这样做。\r然后，我们在 DoJobAsync 中实现后台的异步任务。这里我们简单地使用一个 for 循环，并在其中使用 Task.Delay，从而实现一个拥有进度的异步任务。然后，我们在每次循环中直接修改 progressBar 控件的值。运行程序，就可以直接看到效果了：\n这个问题难道就这么轻松地就解决了吗？其实不是的，因为在异步任务中，很可能会出现在别的线程中操作 UI 线程的资源（也就是控件及其属性），这种情况下程序会报错。所以如果使用这样的方式，通常我们还需要使用老套的 Dispatcher.Invoke 的方式来规避这个问题。但这样就显得不够优雅了。\n那么同样的功能，我们该如何使用 Progress 类来实现呢？\n使用 Progress 类 \u0026para; 首先我们需要稍稍修改一下 DoJobAsync 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 async Task DoJobAsync(IProgress\u0026lt;double\u0026gt; reporter, CancellationToken token) { for (int i = 0; i \u0026lt; 100; i++) { if (token.IsCancellationRequested) return; await Task.Delay(50, token).ConfigureAwait(false); reporter.Report(i + 1); if (token.IsCancellationRequested) { break; } } } 然后，这个 Progress 类的实例来自哪儿呢？我们再修改一下 Button_Click 方法：\n1 2 3 4 5 private async void Button_Click(object sender, RoutedEventArgs e) { var reporter = new Progress\u0026lt;double\u0026gt;(value =\u0026gt; progressBar.Value = value); await DoJobAsync(reporter, CancellationToken.None); } 就这样，我们只需要在使用的时候实例化一个新的即可。它除了我们前面提到的泛型，还传入了一个回调函数，表示每次 Report 时需要执行的逻辑。这里的逻辑非常简单，只需要将传入的 double 类型的数字赋值给进度条的 Value 属性即可。\n那么问题来了：它是如何规避了前面提到的线程问题的呢？我们观察 Progress 类的源代码，可以发现：\n1 2 3 4 5 6 7 8 public Progress() { // Capture the current synchronization context. // If there is no current context, we use a default instance targeting the ThreadPool. _synchronizationContext = SynchronizationContext.Current ?? ProgressStatics.DefaultContext; Debug.Assert(_synchronizationContext != null); _invokeHandlers = new SendOrPostCallback(InvokeHandlers); } 在它的构造函数中，拥有一个 SynchronizationContext 对象，它持有了当前的同步上下文。当我们在 Button_Click 方法中声明它时，因为还在 UI 线程，所以它就保存了这个上下文。然后在它的 Report 方法被调用时，就会在正确的同步上下文（也就是 UI 线程）中执行相关逻辑了。\nInfo\r除了给构造函数传回调，Progress 类还为我们提供了一个 ProgressChanged 事件。注册这个事件可以实现相同的效果，并且也是在相同的同步上下文执行的。\r实现自定义 Progress 类 \u0026para; 如果我们还有其他额外的需求，那么我们还可以自己实现接口，或者继承 Progress 类。官方特意没有将这个类设为 sealed，并且将 OnReport 方法设为 virtual，就是为了满足我们的这些需求。\nNote\r但是如果我们去继承这个 Progress 类，会发现其实我们能自由发挥的空间并不大，因为它其中的很多字段（尤其是同步上下文）都是 private 的，所以我们能做的事情基本上也只有重写 OnReport 方法了。\r比如这里我写了一个子类，从而可以在进度完成后执行一个回调方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class MyProgress\u0026lt;T\u0026gt; : Progress\u0026lt;T\u0026gt; where T : notnull { private readonly Action? _complete; private readonly T _maximum; private bool _isCompleted; public MyProgress(Action\u0026lt;T\u0026gt; handler, Action? complete, T maximum) : base(handler) { _complete = complete; _maximum = maximum; ProgressChanged += CheckCompletion; } protected override void OnReport(T value) { if (_isCompleted) return; base.OnReport(value); } private void CheckCompletion(object? sender, T e) { if (e.Equals(_maximum) \u0026amp;\u0026amp; !_isCompleted) { _isCompleted = true; _complete?.Invoke(); } } } 然后我们就可以这样使用了：\n1 2 3 4 5 6 7 8 9 private async void Button_Click(object sender, RoutedEventArgs e) { var reporter = new MyProgress\u0026lt;double\u0026gt;( value =\u0026gt; progressBar.Value = value, () =\u0026gt; progressBar.Visibility = Visibility.Hidden, 100 ); await DoJobAsync(reporter, CancellationToken.None); } 这里实现的效果是，当异步任务完成后，将会隐藏进度条。\n总结 \u0026para; 不知道大家看完这篇文章的感受如何。其实我在最开始了解文中提到的 IProgress 接口以及 Progress 类时，最大的感受是：微软究竟为我们提前准备好了多少接口和类啊🤣！\n.NET 类中有太多这样的标准库了，但我们也没有什么办法去系统地挖掘与总结。所以只能仰仗大家今后持续不断的交流与学习了。\n参考 \u0026para; How to Report Progress with Async/Await in .NET Core 3 - YouTube\nC# Advanced Async - Getting progress reports, cancelling tasks, and more - YouTube\n","date":"2024-05-09T00:00:00Z","image":"https://s2.loli.net/2024/05/09/RJYeMSKs5q6UdQn.jpg","permalink":"https://blog.coldwind.top/posts/how-to-report-progress/","title":"如何在异步任务中汇报进度"},{"content":"本篇文章对应的教学视频链接：WPF中如何实现符合MVVM模式的文件拖入功能\n原始方式 \u0026para; 在 WPF 中，实现文件拖入功能并不难。稍微在网上搜索一下，就能够得到答案。比如现在有一个窗口，我们只需要设置它的 AllowDrop 属性为 True，然后在 Drop 事件中处理即可。形如：\n1 2 3 \u0026lt;Window ... AllowDrop=\u0026#34;True\u0026#34; Drop=\u0026#34;Window_Drop\u0026#34;\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } private void Window_Drop(object sender, DragEventArgs e) { if (e.Data.GetDataPresent(DataFormats.FileDrop)) { var files = (string[])e.Data.GetData(DataFormats.FileDrop); // 处理拖入的文件 } } } 添加视图模型 \u0026para; 但问题是，如果现在 Window 拥有一个视图模型（ViewModel），形如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class MainViewModel : ViewModelBase { private string? _fileName; public string? FileName { get =\u0026gt; _fileName; set { _fileName = value; OnPropertyChanged(this, nameof(FileName)); } } } Info\r这里我们假定已经实现了 ViewModelBase 类，它实现了 INotifyPropertyChanged 接口，并提供了 OnPropertyChanged 方法以便于通知属性发生了变化。\r然后 Window 上面有一个 TextBox 绑定了这个属性，这又该怎么办呢？\n这里有两种比较简单粗暴的方式：\n为 TextBox 添加一个 Name，然后在 Window 的 Drop 事件中直接修改 TextBox 的 Text 属性，进而使用依赖属性的一些方法来通知绑定的 ViewModel 属性发生了变化 在 Window 的 Drop 事件中直接修改 ViewModel 的属性（获取 Window.DataContext，并将其转为 MainViewModel 类型），然后在 ViewModel 中实现 INotifyPropertyChanged 接口，进而通知 TextBox 的 Text 属性发生了变化 这两种方式都很直接，而且其实都不违背 MVVM 模式。但是这两种方式并不优雅，所以这里我们借助行为（Behaviors）来实现一个更加优雅且通用的方式。\n使用行为 \u0026para; 首先，我们需要安装 Microsoft.Xaml.Behaviors.Wpf 包。然后我们可以创建一个 DropFileBehavior 类，形如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class DropFileBehavior : Behavior\u0026lt;FrameworkElement\u0026gt; { public string[]? Data { get =\u0026gt; (string[]?)GetValue(FilesProperty); set =\u0026gt; SetValue(FilesProperty, value); } public static readonly DependencyProperty FilesProperty = DependencyProperty.Register( nameof(Data), typeof(string[]), typeof(DropFileBehavior), new UIPropertyMetadata(null) ); protected override void OnAttached() { AssociatedObject.AllowDrop = true; AssociatedObject.Drop += DropHandler; } protected override void OnDetaching() { AssociatedObject.Drop -= DropHandler; } private void DropHandler(object sender, DragEventArgs e) { if (e.Data.GetDataPresent(DataFormats.FileDrop)) { Data = (string[])e.Data.GetData(DataFormats.FileDrop); } } } 这个行为大致实现的功能是：\n当附加到一个 FrameworkElement 上时，将其 AllowDrop 属性设置为 True，并注册 Drop 事件 当拖入文件时，将文件路径保存到 Data 依赖属性中 然后我们就可以在 XAML 中使用这个行为了（因为这里我们声明的 Data 属性是一个数组，所以我们稍微修改 MainViewModel 中相关属性的名称及类型，从而实现绑定功能）：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;Window ... xmlns:i=\u0026#34;http://schemas.microsoft.com/xaml/behaviors\u0026#34; xmlns:local=\u0026#34;clr-namespace:YourNamespace\u0026#34;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;local:DropFileBehavior Data=\u0026#34;{Binding FileNames, Mode=OneWayToSource}\u0026#34; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;TextBox Text=\u0026#34;{Binding FileNames[0]}\u0026#34; /\u0026gt; \u0026lt;/Window\u0026gt; 注意这里，我们在书写行为的 Data 属性的绑定时，使用了 Mode=OneWayToSource，这是因为我们只需要将数据从视图传递到视图模型，而不需要反向传递。并且如果不写 Mode，它默认将会是 OneWay，导致可能无法正确通知到 ViewModel。\n制作界面 \u0026para; 最后，我们还可以搞一个“酷炫”的界面，形如：\n首先，我们可以在窗口中添加这样一个置于上方的控件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;Grid Name=\u0026#34;dropFilePanel\u0026#34; Visibility=\u0026#34;Hidden\u0026#34;\u0026gt; \u0026lt;Border Background=\u0026#34;White\u0026#34; Opacity=\u0026#34;0.8\u0026#34; /\u0026gt; \u0026lt;TextBlock HorizontalAlignment=\u0026#34;Center\u0026#34; VerticalAlignment=\u0026#34;Center\u0026#34; Text=\u0026#34;将文件拖放到此处\u0026#34; /\u0026gt; \u0026lt;Rectangle Width=\u0026#34;200\u0026#34; Height=\u0026#34;100\u0026#34; Stroke=\u0026#34;Gray\u0026#34; RadiusX=\u0026#34;10\u0026#34; RadiusY=\u0026#34;10\u0026#34; StrokeDashArray=\u0026#34;3,4\u0026#34; StrokeThickness=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;/Grid\u0026gt; 同时，因为我们现在有了这个专门的用于放置文件的面板，所以我们可以将之前添加给窗口的行为转移到它身上，形如：\n1 2 3 4 5 \u0026lt;Grid Name=\u0026#34;dropFilePanel\u0026#34; Visibility=\u0026#34;Hidden\u0026#34;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;local:DropFileBehavior Data=\u0026#34;{Binding FileNames, Mode=OneWayToSource}\u0026#34; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; ... 但是我们要控制它在合适的时机出现与消失。这里我们可以使用触发器与行为来快速地实现这一效果。具体来说，我们可以给窗口添加这样的触发器：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;Window ... xmlns:b=\u0026#34;http://schemas.microsoft.com/xaml/behaviors\u0026#34;\u0026gt; \u0026lt;b:Interaction.Triggers\u0026gt; \u0026lt;b:EventTrigger EventName=\u0026#34;DragEnter\u0026#34;\u0026gt; \u0026lt;b:ChangePropertyAction TargetObject=\u0026#34;{Binding ElementName=dropFilePanel}\u0026#34; PropertyName=\u0026#34;Visibility\u0026#34; Value=\u0026#34;Visible\u0026#34; /\u0026gt; \u0026lt;/b:EventTrigger\u0026gt; \u0026lt;b:EventTrigger EventName=\u0026#34;DragLeave\u0026#34;\u0026gt; \u0026lt;b:ChangePropertyAction TargetObject=\u0026#34;{Binding ElementName=dropFilePanel}\u0026#34; PropertyName=\u0026#34;Visibility\u0026#34; Value=\u0026#34;Hidden\u0026#34; /\u0026gt; \u0026lt;/b:EventTrigger\u0026gt; \u0026lt;/b:Interaction.Triggers\u0026gt; ... 这样，当鼠标拖入窗口时，dropFilePanel 就会显示出来；当鼠标拖出窗口时，dropFilePanel 就会被隐藏。\n实际测试后会发现，当我们将文件拖到上方并松开左键后，虽然行为得到了正确的响应，但面板并没有消失。这是因为我们上面写的触发器只会在鼠标拖动状态离开窗口后才会隐藏面板。所以这里，我们可以再为面板添加一个触发器，并在它触发了 Drop 事件后将自身隐藏：\n1 2 3 4 5 6 \u0026lt;Grid Name=\u0026#34;dropFilePanel\u0026#34; Visibility=\u0026#34;Hidden\u0026#34;\u0026gt; \u0026lt;b:Interaction.Triggers\u0026gt; \u0026lt;b:EventTrigger EventName=\u0026#34;Drop\u0026#34;\u0026gt; \u0026lt;b:ChangePropertyAction PropertyName=\u0026#34;Visibility\u0026#34; Value=\u0026#34;Hidden\u0026#34; /\u0026gt; \u0026lt;/b:EventTrigger\u0026gt; \u0026lt;/b:Interaction.Triggers\u0026gt; 这样，上面动图中的效果就实现了。\n总结 \u0026para; WPF 开发必然会经常和控件的事件打交道。但很多时候，如果我们希望遵循 MVVM 模式，可能就会不知所措。相信大家通过这篇文章的代码，都能够充分领略到使用触发器与行为的强大之处。当然，这里只是一个简单的例子，实际开发中，我们还可以为上面的例子添加更多丰富的功能及特效。这些就有待大家的探索了。\n大家如果有什么自己的好方法，也欢迎在文章评论区留言，分享给大家。\n","date":"2024-05-08T00:00:00Z","image":"https://s2.loli.net/2024/05/08/tw73xXjhTbN8pZQ.jpg","permalink":"https://blog.coldwind.top/posts/drop-file-mvvm/","title":"如何在 WPF 中实现符合 MVVM 模式的文件拖入功能"},{"content":"在 .NET Core 项目中，我们可以使用 appsettings.json 配置文件来存储应用程序的配置信息。在这篇文章中，我们将学习如何使用 appsettings.json 配置文件。\nappsettings.json 是一个相较于 App.config 更加灵活的配置文件，是 .NET Core 以来新增的一种配置方式，提供了更多的灵活性。\n快速入门 \u0026para; 我们可以在项目中创建一个 appsettings.json 文件，然并将其生成操作设置为「较新时复制」或「总是复制」，这样在项目构建时，appsettings.json 文件会被复制到输出目录中。\n然后我们可以在其中添加如下内容：\n1 2 3 4 5 6 7 8 { \u0026#34;AppSettings\u0026#34;: {\t\u0026#34;LogLevel\u0026#34;:\u0026#34;Warning\u0026#34;, \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;this is the connection string\u0026#34; }\t} } 这样我们就可以尝试读取了。我们使用 NuGet 包管理器安装 Microsoft.Extensions.Configuration.Json 包。它会隐式安装 Microsoft.Extensions.Configuration 等依赖项，这些我们不需要显式安装。\n然后我们可以在代码中读取配置文件：\n1 2 3 4 5 using Microsoft.Extensions.Configuration; var configuration = new ConfigurationBuilder() .AddJsonFile(\u0026#34;appsettings.json\u0026#34;, optional: false, reloadOnChange: true) .Build(); 这样我们就可以获取上面的配置信息了：\n1 2 var logLevel = configuration[\u0026#34;AppSettings:LogLevel\u0026#34;]; var connectionString = configuration[\u0026#34;AppSettings:ConnectionStrings:Default\u0026#34;]; 这里的形如 AppSettings.LogLevel 是一种特殊的写法，简单来说就是借助 : 来表示 JSON 中的层级关系。\n如果要获取的配置项是一个数字，我们除了可以先通过上述方式获取到字符串，进而使用 int.Parse 或 Convert.ToInt32 等方法进行转换，还可以使用 GetValue 方法：\n1 2 3 4 // 传统方法 var logLevel = int.Parse(configuration[\u0026#34;AppSettings:LogLevel\u0026#34;]); // 使用 GetValue 方法 var logLevel = configuration.GetValue\u0026lt;int\u0026gt;(\u0026#34;AppSettings:LogLevel\u0026#34;); 对于连接字符串，我们还可以使用 GetConnectionString 方法：\n1 var connectionString = configuration.GetConnectionString(\u0026#34;Default\u0026#34;); 可选与自动重载 \u0026para; 在上面的代码中，我们可以看到 AddJsonFile 方法有两个参数，optional 和 reloadOnChange：\noptional 参数表示是否允许配置文件不存在，如果设置为 false，则会抛出异常，否则会忽略。 reloadOnChange 参数表示是否在配置文件发生变化时重新加载配置文件。如果设置为 true，则会在配置文件发生变化时重新加载配置文件。 比如我们可以用下面的例子测试自动重载的效果：\n1 2 3 4 5 6 7 8 9 var configuration = new ConfigurationBuilder() .AddJsonFile(\u0026#34;appsettings.json\u0026#34;, optional: false, reloadOnChange: true) .Build(); while (true) { Console.WriteLine(configuration[\u0026#34;AppSettings:LogLevel\u0026#34;]); Thread.Sleep(1000); } 在运行程序后，我们可以修改 appsettings.json 文件中的 LogLevel 配置，然后我们会发现程序会自动重新加载配置文件。注意这里我们修改的是输出目录（也就是 .exe 文件所在位置）下的 appsettings.json 文件，而不是项目中的 appsettings.json 文件。\n添加多个 JSON 文件 \u0026para; 如果只能添加一个 JSON 文件，那么配置文件的灵活性就大大降低了。事实上，我们可以通过多次调用 AddJsonFile 方法来添加多个 JSON 文件。一个典型的情形是添加一个 appsettings.Development.json 文件，用于存储开发环境的配置信息。\n1 2 3 4 var configuration = new ConfigurationBuilder() .AddJsonFile(\u0026#34;appsettings.json\u0026#34;, optional: false, reloadOnChange: true) .AddJsonFile(\u0026#34;appsettings.Development.json\u0026#34;, optional: true, reloadOnChange: true) .Build(); 这样我们就可以在 appsettings.Development.json 文件中存储开发环境的配置信息，而在 appsettings.json 文件中存储通用的配置信息。\n不仅如此，这二者之间存在优先级，或者说覆盖关系。具体来说：\n如果 appsettings.json 和 appsettings.Development.json 中都有相同的配置项，那么 appsettings.Development.json 中的配置项会覆盖 appsettings.json 中的配置项 如果 appsettings.Development.json 中没有某个配置项，而 appsettings.json 中有，那么会使用 appsettings.json 中的配置项 如果 appsettings.Development.json 中有某个配置项，而 appsettings.json 中没有，那么会使用 appsettings.Development.json 中的配置项 使用强类型配置 \u0026para; 在上面的例子中，我们使用 configuration[\u0026quot;AppSettings:LogLevel\u0026quot;] 来获取配置信息，这种方式是一种弱类型的方式。我们也可以使用强类型的方式来获取配置信息。\n我们修改一下 appsettings.json 文件中的配置项：\n1 2 3 4 5 6 7 { \u0026#34;UserSettings\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;Age\u0026#34;: 18, \u0026#34;IsActive\u0026#34;: true } } 然后我们定义一个强类型的配置类：\n1 2 3 4 5 6 public class UserSettings { public string Name { get; set; } public int Age { get; set; } public bool IsActive { get; set; } } 在获取配置前，我们还需要安装一个 NuGet 包：Microsoft.Extensions.Options.ConfigurationExtensions。然后我们就可以这样获取配置信息：\n1 var userSettings = configuration.GetSection(\u0026#34;UserSettings\u0026#34;).Get\u0026lt;UserSettings\u0026gt;(); 这样我们就可以获取到 UserSettings 对象了，然后就可以使用 userSettings.Name、userSettings.Age、userSettings.IsActive 来获取配置信息了。\n但是需要注意，因为这里的 userSettings 实例已经初始化，所以前面提到的自动重载功能不再生效。如果需要自动重载，我们需要重新获取 userSettings 对象。\n添加环境变量和命令行参数 \u0026para; 在 .NET Core 中，我们还可以通过环境变量和命令行参数来覆盖配置文件中的配置信息。我们需要再安装两个 NuGet 包：\nMicrosoft.Extensions.Configuration.EnvironmentVariables Microsoft.Extensions.Configuration.CommandLine 然后我们可以这样添加环境变量和命令行参数：\n1 2 3 4 5 var configuration = new ConfigurationBuilder() .AddJsonFile(\u0026#34;appsettings.json\u0026#34;, optional: false, reloadOnChange: true) .AddEnvironmentVariables() .AddCommandLine(args) .Build(); 这样我们就可以通过环境变量和命令行参数来覆盖配置文件中的配置信息了。\n比如我们可以创建一个 .bat 批处理文件：\n1 2 3 4 5 @echo off set UserSettings__Name=Bob set UserSettings__Age=20 .\\Demo.exe 或者还可以使用 PowerShell：\n1 2 3 4 $env:UserSettings__Name = \u0026#34;Bob\u0026#34; $env:UserSettings__Age = 20 .\\Demo.exe 总结 \u0026para; 相信通过这篇文章，大家已经认识到了 appsettings.json 配置文件的强大之处。它不仅提供了一种灵活的配置方式，还提供了多种配置方式的组合，使得我们可以更加灵活地配置应用程序。\n但是它也有一些局限性。最重要的一条就是它的配置项是“只读”的，也就是不能像 App.config 那样在运行时方便地修改配置项。毕竟，一个项目中可能存在多个配置项，而不是只有一个 appsettings.json 文件。此时如果修改了，该保存到哪个文件呢？\n当然，如果只有一个配置文件，那么 appsettings.json 是一个不错的选择。比如我们可以使用 Newtonsoft.Json 来轻松地写入 JSON 文件，这样就可以实现配置项的修改了。\n最后，其实通常情况下，我们并不会使用上面的方式读取配置项，而是会更进一步，使用 Host 作为整个程序的入口，并读取配置、注入服务等。在之后的文章中，我们会学习如何使用 Host 来构建一个 .NET 应用程序。\n","date":"2024-04-22T00:00:00Z","image":"https://s2.loli.net/2024/04/22/7ZhNX9B6CefQbuE.png","permalink":"https://blog.coldwind.top/posts/how-to-use-appsettings/","title":"如何使用 appsettings.json 配置文件？"},{"content":"不知道大家有没有看过这样一个视频：\n（或者也可以看油管上的 原版视频）\n我们这次就来玩一玩，如何使用 Rx.NET 来模拟这个情景短剧。\n简单分析每个人的特点 \u0026para; 通过观看视频，我们发现一共有五个人，且这五个人各有特点，或者说各自会在特定情况下触发自己的恐惧症，进而发出尖叫。具体来说：\nLee：对于“AAGH!”（也就是“啊！”）这个词很恐惧 且这个词必须是别人发出的 Jim：对于道歉（或者说“Sorry”这个词）很恐惧 自己说的这个词也是可以触发自己的恐惧的 Karen：对于重复的话很恐惧 两句重复的话必须都是别人说的 （从视频中来看，两句重复的话甚至可以间隔很久，但这种情况难以概括，且视频中其他时候也有重复的话，但并未触发，所以存在 BUG，暂不考虑） Ronnie：对于“尴尬的沉默”很恐惧 也就是说，如果有人说了一句话，然后没有人回应，那么就会触发 前提是必须有人先说了什么，而不是打一开始就没有任何人说话 Tim：对于别人因恐惧而发出尖叫这件事情感到恐惧，并且会吓出狗叫 当其他有人发出了恐惧的尖叫，且之后不再会有人尖叫时，他会发出狗叫 大家可以多看几遍视频，尤其是靠近后面的地方，他们连续相继发出尖叫声的片段，看看我上面总结的是否正确。\n那么现在，我们就来模拟这个情景短剧吧。\n实现消息总线 \u0026para; 在模拟每个人之前，我们首先需要有一个消息总线（Message Bus）。有了这个总线，我们才可以既让所有人都能够收听（或者说订阅）这个总线，又可以向总线中发送消息。\n在 Rx.NET 中，Subject 这个类型就是典型的能够实现这一效果的类。我们可以使用它来实现一个消息总线。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MessageBus : IDisposable { // 内部使用一个 Subject 对象 private readonly Subject\u0026lt;Message\u0026gt; _subject = new(); // 当用于订阅时，返回一个 IObservable\u0026lt;Message\u0026gt; 对象，从而封装类中其他功能 public IObservable\u0026lt;Message\u0026gt; Messages =\u0026gt; _subject.AsObservable(); // 当向总线中发送消息时，底层会调用 Subject 的 OnNext 方法 public void SendMessage(Message message) { if (message.Content == \u0026#34;exit\u0026#34;) _subject.OnCompleted(); else _subject.OnNext(message); } public void Dispose() { _subject.Dispose(); } } 同时，我们也需要一个 Message 类型，从而更好地让接下来的每一个人都能够判断自己是否应该发出尖叫。\n1 record Message(string Sender, string Content); 是的，一个简单的记录类就可以满足我们的需求了。上面的每一个人，它们都只需要知道是谁说的，以及说了什么，就足够处理各自的逻辑了。\nInfo\r在 ReactiveUI 中也有一个消息总线类型，名叫 MessageBus。它底层其实就是借助了一个 Subject 来实现的。当然实际上更复杂一些，因为还有与 Scheduler 相关的一些额外的功能，所以它额外实现了一个名为 ScheduledSubject 的类。\r模拟每一个人的行为 \u0026para; 下面我们就根据出场顺序，来逐个模拟每个人的逻辑吧。这里为了简单起见，我们统一使用小写，并且为所有人设定了一个固定的延迟。此外，还需要给两个人额外的时间：\n给 Ronnie 一个时间阈值，表示多久之后才会被她判定为长时间的“尴尬的沉默” 给 Tim 一个相对更长一点的延迟，从而让他能够在确保其他人都不再尖叫之后，才发出自己的狗叫 1 2 3 var reactionDelay = TimeSpan.FromSeconds(0.25); var ronnieSilenceThreshold = TimeSpan.FromSeconds(3); var timReactionDelay = TimeSpan.FromSeconds(0.3); 同时，我们还要声明前面定义好的消息总线：\n1 var bus = new MessageBus(); 这样，每个人都能够收听这个总线，并且自己发出的尖叫也要传递给这个总线。\nLee \u0026para; Lee 的逻辑很简单，只要听到了别人说的 “AAGH!”这个词，就会发出尖叫。\n1 2 3 4 using var agent1 = bus.Messages .Where(m =\u0026gt; m.Content == \u0026#34;aagh\u0026#34; \u0026amp;\u0026amp; m.Sender != \u0026#34;agent1\u0026#34;) // 别人说的 aagh .Delay(reactionDelay) .Subscribe(_ =\u0026gt; bus.SendMessage(new(\u0026#34;agent1\u0026#34;, \u0026#34;aagh\u0026#34;))); Jim \u0026para; Jim 的逻辑也很简单，只要听到了 “Sorry” 这个词（不用管是谁发出的），就会发出尖叫。\n1 2 3 4 using var agent2 = bus.Messages .Where(m =\u0026gt; m.Content == \u0026#34;sorry\u0026#34;) // 无论是谁说的 sorry .Delay(reactionDelay) .Subscribe(_ =\u0026gt; bus.SendMessage(new(\u0026#34;agent2\u0026#34;, \u0026#34;aagh\u0026#34;))); Karen \u0026para; Karen 的逻辑稍微复杂一点，因为她需要判断两句话是否重复，且都是别人说的。\n1 2 3 4 5 6 7 8 using var agent3 = bus.Messages .Buffer(2, 1) .Where(ms =\u0026gt; ms.Count == 2 \u0026amp;\u0026amp; ms[0].Content == ms[1].Content \u0026amp;\u0026amp; ms[0].Sender != \u0026#34;agent3\u0026#34; \u0026amp;\u0026amp; ms[1].Sender != \u0026#34;agent3\u0026#34;) .Delay(reactionDelay) .Subscribe(_ =\u0026gt; bus.SendMessage(new(\u0026#34;agent3\u0026#34;, \u0026#34;aagh\u0026#34;))); Ronnie \u0026para; Ronnie 的逻辑也比较简单，只要有人说了话，然后没有人回应，就会发出尖叫。那么 Rx 中的 Throttle 方法简直就是为她量身打造的。\n1 2 3 4 var agent4 = bus.Messages .Throttle(ronnieSilenceThreshold) // .Delay(reactionDelay) // 这句也可以不写 .Subscribe(_ =\u0026gt; bus.SendMessage(new(\u0026#34;agent4\u0026#34;, \u0026#34;aagh\u0026#34;))); Tim \u0026para; Tim 其实与 Ronnie 类似，只要有人发出了尖叫，然后之后没有人再发出尖叫，他就会发出狗叫。所以我们同样可以使用 Throttle 方法来实现。\n1 2 3 4 var agent5 = bus.Messages .Where(m =\u0026gt; m.Content == \u0026#34;aagh\u0026#34;) .Throttle(timReactionDelay) .Subscribe(_ =\u0026gt; bus.SendMessage(new(\u0026#34;agent5\u0026#34;, \u0026#34;woof\u0026#34;))); 放在一起 \u0026para; 最后，我们将上面的代码放在一起。为了能够便于观察效果，我们使用 LINQPad 来简单地搭建这段代码，并且额外添加一个 agent，代表用户的输入。这样，我们就可以通过输入来模拟每个人的发言了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 bool isCompleted = false; bus.Messages .Subscribe( m =\u0026gt; Console.WriteLine($\u0026#34;[{DateTime.Now: mm:ss.fff}] {m.Sender}: {m.Content}\u0026#34;), () =\u0026gt; isCompleted = true ); while (!isCompleted) { var input = Util.ReadLine(); bus.SendMessage(new(\u0026#34;user\u0026#34;, input)); } 完整版代码可以查看这个 Gist。\n运行看一下效果。输入“aagh”会看到：\n1 2 3 4 5 [55:26.812] user: aagh [55:27.112] agent1: aagh [55:27.362] agent3: aagh [55:27.625] agent1: aagh [55:27.941] agent5: woof 输入“sorry”会看到：\n1 2 3 4 5 6 [55:34.985] user: sorry [55:35.236] agent2: aagh [55:35.499] agent1: aagh [55:35.763] agent3: aagh [55:36.027] agent1: aagh [55:36.339] agent5: woof 总结 \u0026para; 通过这个简单的例子，我们可以看到，Rx.NET 的强大之处。我们可以通过简单的类似 LINQ 一样的查询，就能够实现复杂的逻辑。这种方式不仅简洁，而且易于理解，同时也能够很好地处理异步的情况。试想一下，如果我们使用传统的多线程或异步编程来实现相同的效果，那么代码会变得多么复杂。\n之后我们还会继续探讨 Rx.NET 的更多用法，用更多实际且生动的例子，来帮助大家更好地理解这个库。\n","date":"2024-04-20T00:00:00Z","image":"https://s2.loli.net/2024/04/20/tAq5BvYJUkQgReP.png","permalink":"https://blog.coldwind.top/posts/phobia-workshop/","title":"如何用 Rx.NET 来模拟情景短剧《恐惧症研讨会》"},{"content":" 便捷的 ForEach 方法 \u0026para; C# 中，List 类型（其他还包括 ImmutableList 等）拥有一个名为 ForEach 的方法。它的作用可以理解为传统 foreach 语句的另一种函数式的写法。比如：\n1 2 3 4 5 6 7 8 var list = new List\u0026lt;int\u0026gt; { 1, 2, 3, 4, 5 }; // 传统的 foreach 语句 foreach (var n in list) { Console.WriteLine(n); } // 便捷的 ForEach 方法可以实现相同的效果 list.ForEach(n =\u0026gt; Console.WriteLine(n)); （One-liner 狂喜）\n此外，Array 类还拥有一个 ForEach 静态方法，同样可以实现类似的功能。但很快我们就会发现，为什么这么好用的方法，我们却不能用在一个 IEnumerable （这里指的是泛型接口 IEnumerable\u0026lt;T\u0026gt;，下面不再赘述）接口类型上呢？\nNote\r在某些读者可能会发问之前，我把“丑话说在前面”：将一个 IEnumerable 类型使用 ToList() 方法转为 List，只为使用 ForEach() 绝对不是一个好主意，因为这很可能会涉及到消耗 LINQ 语句，创建新对象，以及逐个填充元素等。\r其实这样设计是有原因的。我大概总结了这么几条，大家听一听是不是这么个道理。\n添加 ForEach 方法的后果 \u0026para; 破坏接口的纯粹性 \u0026para; 这句话如果说得再“专业”一点，就是违背了 SOLID 原则中的“单一职责原则”（Single responsibility principle）以及“接口隔离原则”（Interface segregation principle）。\n怎么讲？我们可以看一下 IEnumerable 接口的定义：\n1 2 3 4 5 6 7 namespace System.Collections.Generic { public interface IEnumerable\u0026lt;out T\u0026gt; : IEnumerable { new IEnumerator\u0026lt;T\u0026gt; GetEnumerator(); } } 非常地干净。就连它的名字也表明了，它只是表明一个对象拥有“被枚举”的能力。但是 ForEach 方法通常会伴随着一些执行逻辑，这可能就与接口的初衷不符了。\n不同于 LINQ 中的 Select、Where、OrderBy 等，它们都是对于数据的映射、筛选、排序等，通常不会包含什么逻辑操作。试想，如果 LINQ 中包含了逻辑操作，尤其还是耗时的操作（比如占用 CPU 的复杂计算、IO 操作等）时，LINQ 的使用将会变得不那么可靠。\n所以，假如 ForEach 方法中也存在这样的耗时操作，我们更应该考虑的做法是使用异步编程（比如创建多个异步任务，然后使用 Task.WhenAll 方法进行等待），使用 Parallel 类或者 PLINQ 等，从而使得我们的 IEnumerable 对象只包含数据序列，不包含不可控的操作逻辑。\n这里给出一个简单的使用异步的例子：\n1 2 3 4 IEnumerable\u0026lt;int\u0026gt; items = ...; var tasks = items.Select(x =\u0026gt; CalculateValueAsync(x)); await Task.WhenAll(tasks); var results = tasks.Select(t =\u0026gt; t.Result).ToList(); 方法带来的副作用 \u0026para; 诚然，我们可以自己写一个扩展方法，从而让 IEnumerable 对象能够像 List 那样使用 ForEach 方法：\n1 2 3 4 5 6 7 8 9 10 static class EnumerableExtensions { public static void ForEach\u0026lt;T\u0026gt;(this IEnumerable\u0026lt;T\u0026gt; items, Action\u0026lt;T\u0026gt; action) { foreach (var item in items) { action.Invoke(item); } } } 但这可能会造成对 LINQ 现有功能的污染。为什么这么说呢？\n我们来想一想，LINQ 提供的功能主要是做什么的？其实主要是对于数据的映射、筛选、排序等。这些方法通常都被认为不会对原始数据造成影响，或者修改。虽然这些方法也会接收一个回调，但是这个回调一定是个 Func，从而返回映射后的对象、筛选及排序的依据等。\n但是 ForEach 方法则不同，它接收的是一个 Action，那就是说这个回调并不需要返回什么。此时我们的操作通常就有可能会对原始数据产生影响了。比如：\n1 2 3 4 5 6 List\u0026lt;Employee\u0026gt; employees = ...; employees.ForEach(e =\u0026gt; { if (e.IsPromoted) // 如果员工晋升，则涨薪 e.Salary += 1000; }) 所以，使用 ForEach 时我们是倾向于对于原本的数据进行一定的操作的。\n当然这里仅仅表示一种推测，实际的用法并不绝对。即便我们使用 LINQ 中的 Select 等方法，也同样是可以做到对于数据的修改的，这一点 LINQ 并没有办法阻止我们。所以这里主要还是一个“轻重”关系。相较于 LINQ 的方法，ForEach 是更倾向于会对数据进行操作的。\n性能和资源等方面的考虑 \u0026para; 还有一个点，就是 拥有 ForEach 方法的 List（类似的还有 Array.ForEach 静态方法），它们被操作的对象都有一个显著特点：元素数量是已知（或者说有限）的。这一点非常重要，因为一个 IEnumerable 对象完全有可能是无限的！\n1 2 3 4 5 6 7 IEnumerable\u0026lt;int\u0026gt; GenerateNumbers() { while (true) { yield return 0; } } 从这个角度考虑，对一个容量未知的集合轻易开展 ForEach 这样的操作，其实是充满风险的。不仅如此，ForEach 方法不像是 foreach 语句那样，可以在其中书写 continue、break 或 return 等语句，这就意味着它一旦开始，就只能将整个集合中的全部元素逐个来一遍才行了。\n所以从这个角度考虑，不给 IEnumerable 对象提供这样的扩展方法，似乎是非常有道理的。当然，你依旧可以说，LINQ 的方法遇到这样的极端情况，同样束手无策呀？的确，但 LINQ 针对的就是 IEnumerable 类型，这是无法避免的，只能希望开发者清楚自己面对的集合是有限的还是无限的。\n＜2024 年 5 月 7 日更新＞\n最近 Nick Chapsas 在他的一期视频中讨论了 ForEach 方法的性能。通过 Benchmark（在视频的约 5:45 处）可以看出，它的性能是显著低于传统的 for 以及 foreach 的：\n1 2 3 4 5 | Method | Mean | Allocation | | ------- | ---------- | ---------- | | for | 424.9 us | - | | foreach | 426.4 us | - | | ForEach | 1,785.0 us | 88 B | Info\r关于上面的表格，有一些需要额外补充的内容：\n上面的表格省去了一些列，只保留了主要部分 测试环境是最新的 .NET 9（预览版），所以 foreach 与 for 拥有近乎一样的性能，且没有内存开销 ForEach 速度慢了约 4 倍，且拥有内存开销（因为存在委托和相应的闭包） 所以这更加证明了，ForEach 方法并不是一个高性能的方法，如果我们需要对一个集合进行遍历，还是应该使用传统的 for 或 foreach。\n总结 \u0026para; 总的来说，虽然为 IEnumerable\u0026lt;T\u0026gt; 添加一个 ForEach 方法在技术上是可行的，但由于设计哲学、清晰的代码维护、性能考虑和潜在的副作用，.NET 框架设计者选择不在 IEnumerable\u0026lt;T\u0026gt; 中直接提供这样的方法。不过，大家如果需要，可以自定义扩展方法来实现这一功能。但前提是要清楚这样做可能会带来的后果。\n","date":"2024-04-17T00:00:00Z","image":"https://s2.loli.net/2024/04/17/diwtgBYmexonr14.jpg","permalink":"https://blog.coldwind.top/posts/why-ienumerable-no-foreach/","title":"为什么 IEnumerable 对象没有 ForEach 方法？"},{"content":" 本文有对应的视频教程：哔哩哔哩\n自从 C# 5.0 引入了 async 和 await 语法以后，异步编程变得非常简单，而 Task 类型也在开发中扮演着相当重要的角色，存在感极高。但是在 .NET Core 2.0 这个版本，微软引入了一个新的类型 ValueTask，那么这个类型是什么？为什么我们需要它？什么情况下应该使用它？我们今天就来探讨一下。\n简单回顾 Task 类型 \u0026para; 在异步编程中，我们经常会使用 Task 类型来表示一个异步操作或者说异步任务。相较于其他一些主流编程语言，C# 中的异步任务其实开销很小。比如知乎上的大佬 hez2010 在他的这个回答中提到，C# 的 Task 类型通常只占用 64~136 B 的内存，而 Go 语言的一个 goroutine 至少占用 2 KB 的内存。\n不仅如此，Task 还有许多优化技巧，比如：\n如果想直接返回一个结果，可以使用 Task.FromResult 方法 如果想直接返回一个已经完成的任务，可以使用 Task.CompletedTask 如果想直接返回一个已经取消的任务，可以使用 Task.FromCanceled 如果想直接返回一个已经失败的任务，可以使用 Task.FromException 等等。所以从 C# 5.0（大概是 .NET Framework 4 时代）开始，直到 .NET Core 2.0 之前，一直相安无事。\n传统 Task 类型的问题 \u0026para; 但是，随着 .NET 开始跨平台，能使用 C# 的场景越来越多，微软的“野心”也越来越大，开始从各种角度优化 C# 的性能，从而使 .NET 能够胜任各种任务场景。除了引入 Span、Memory、ref struct 等新特性外，还引入了 ValueTask。那么，传统的 Task 类型有什么问题呢？\n首先我们要知道，Task 包含泛型版本和非泛型版本，分别对应有无返回值的异步任务。而 ValueTask 在诞生之初，只有一个泛型版本。换句话说，设计者认为，ValueTask 应当只适用于有返回值的异步任务。所以这里我们来看一个典型的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private readonly ConcurrentDictionary\u0026lt;int, string\u0026gt; _cache = new (); public async Task\u0026lt;string\u0026gt; GetMessageAsync(int id) { if (_cache.TryGetValue(id, out var message)) { return message; } message = await GetMessageFromDatabaseAsync(id); _cache.TryAdd(id, message); return message; } 在上面的 GetMessageAsync 方法中，我们首先尝试从缓存中获取消息，如果没有找到，就再尝试从数据库中获取。但这里有一个问题，如果缓存中有数据，那么虽然我们好像会直接返回一个值。但是，由于 GetMessageAsync 方法是一个异步方法，所以实际上会返回一个 Task\u0026lt;string\u0026gt; 类型的对象。这就意味着，即便我们本可以只返回一个值，我们依旧会多创建一个 Task 对象，这就导致了无端的内存开销。\nInfo\r这种在异步任务中直接返回一个值的情况，我们称之为“同步完成”，或者“返回同步结果”。线程进入这个异步任务后，并没有碰到 await 关键字，而是直接返回。也就是说，这个异步任务自始至终都是在同一个线程上执行的。\rValueTask 简介 \u0026para; 所以，ValueTask 的主要作用就是解决这个问题。它在 .NET Core 2.0 被正式引入，并在 .NET Core 2.1 得到了增强（新增了 IValueTaskSource\u0026lt;T\u0026gt; 接口，从而使它可以拥有诸如 IsCompleted 等属性），并且还添加了非泛型的 ValueTask 类型（这个我们稍后再说）。\nValueTask 我们先不要去思考它是否为值类型，而是可以这么理解：它适用于可能返回一个 Value，也可能返回一个 Task 的情形。也就是说，它非常适合上面的“缓存命中”的典型场景。我们可以把上面的代码修改为：\n1 2 3 4 5 6 7 8 9 10 11 12 public async ValueTask\u0026lt;string\u0026gt; GetMessageAsync(int id) { if (_cache.TryGetValue(id, out var message)) { return message; } message = await GetMessageFromDatabaseAsync(id); _cache.TryAdd(id, message); return message; } 此时，如果缓存中有数据，那么我们可以直接返回一个 ValueTask\u0026lt;T\u0026gt; 对象，而不需要再创建一个 Task\u0026lt;T\u0026gt; 对象。这样就避免了无端的堆内存开销；否则，我们才会创建 Task\u0026lt;T\u0026gt; 对象。或者说，在这种情况下，ValueTask 的性能会退化为 Task（甚至可能还稍微低一丁点，因为涉及到更多的字段，以及值拷贝等）。\nInfo\r至于非泛型版本的 ValueTask，它的使用情形就更少了。它只有在即使异步完成也可以无需分配内存的情况下才会派上用场。ValueTask 的“发明者”Stephen Toub 在他的文章中提到，除非你借助 profiling 工具确认 Task 的这一丁点开销会成为瓶颈，否则不需要考虑使用 ValueTask。\r这时候我们再来思考它的性能究竟如何：\n顾名思义，ValueTask 是一个值类型，可以在栈上分配，而不需要在堆上分配。不仅如此，它因为实现了一些接口，从而使它可以像 Task 一样被用于异步编程。所以，照理说，ValueTask 的性能要比 Task 更好很多（就如同 ValueTuple 之于 Tuple、Span 之于 Array 一样）。\n但是，ValueTask 真的这么美好吗？它是不是可以完全替代 Task 呢？事情恐怕并没有这么简单。\nValueTask 的注意事项 \u0026para; 现在，我们该谈一谈 ValueTask 在使用时需要注意的地方了。\nValueTask 不能被多次等待（await） \u0026para; ValueTask 底层会使用一个对象存储异步操作的状态，而它在被 await 后（可以认为此时异步操作已经结束），这个对象可能已经被回收，甚至有可能已经被用在别处（或者说，ValueTask 可能会从已完成状态变成未完成状态）。而 Task 是绝对不可能发生这种情况的，所以可以被多次等待。\n不要阻塞 ValueTask \u0026para; ValueTask 所对应的 IValueTaskSource 并不需要支持在任务未完成时阻塞的功能，并且通常也不会这样做。这意味着，你无法像使用 Task 那样在 ValueTask 上调用 Wait、Result、GetAwaiter().GetResult() 等方法。\n但换句话说，如果你可以确定一个 ValueTask 已经完成（通过判断 IsCompleted 等属性的值），那么你可以通过 Result 属性来安全地获取 ValueTask 的结果。\nInfo\r微软专门添加了一个与这个有关的警告：CA2012\r不要在多个线程上同时等待一个 ValueTask \u0026para; ValueTask 在设计之初就只是用来解决 Task 在个别情况下的开销问题，而不是打算全面取代 Task。因此，Task 的很多优秀且便捷的特性它都不用有。其中一个就是线程安全的等待。\n也就是说，ValueTask 底层的对象被设计为只希望被一个消费者（或线程）等待，因此并没有引入线程安全等机制。尝试同时等待它可能很容易引入竞态条件和微妙的程序错误。而 Task 支持任意数量的并发等待。\n如何克服 ValueTask 的局限性 \u0026para; 在实际使用过程中，难免遇到需要突破它的上述限制的情况。那么我们该怎么办呢？这里给出几种常见情况的对应方式：\n如果希望用阻塞的方式（Result 与 .GetAwaiter().GetResult()）获取 ValueTask\u0026lt;T\u0026gt; 的结果，可以先判断 IsCompleted 或 IsCompletedSuccessfully 等属性的值，确认它已经完成，然后再获取结果 如果希望等待多次，或在多个线程中等待等，那么可以使用 AsTask() 方法将其转为一个普通的 Task，进而再进行各种 Task 的常用操作 基于 ValueTask 的原理及限制，一个普遍认同的推荐用法是：\nTip\r绝大多数情况下，都推荐直接使用 await 关键字来等待一个返回值为 ValueTask\u0026lt;T\u0026gt; 的异步任务并获取结果，而不是试图将其返回值赋值给一个变量（最多是搭配 ConfigureAwait() 进行使用）；否则，建议使用 AsTask() 方法将其转为传统的 Task，再进行常规操作。\r总结 \u0026para; 总的来说，ValueTask 确实有很多闪光点，比如在栈上分配来避免堆分配的性能开销，但它也有一些让人头疼的限制，比如不能被多次等待。使用它就像是在走钢丝，一不小心就可能掉进性能优化的陷阱里。但别担心，大多数情况下，我们还是可以安全地使用 await 来等待 ValueTask\u0026lt;T\u0026gt; 的，只要我们不试图把它当作 Task 的替代品来用就好。\n希望看了这篇文章之后，大家能够正确使用 ValueTask。\n参考链接 \u0026para; ValueTask Source Code Understanding the Whys, Whats, and Whens of ValueTask | .NET Blog Working with ValueTask in C# | CodeGuru.com Task vs ValueTask: When Should I use ValueTask? | YouTube.com Understanding how to use Task and ValueTask | YouTube.com ","date":"2024-04-12T00:00:00Z","image":"https://s2.loli.net/2024/04/14/P4HJMlIpSxY6CDn.jpg","permalink":"https://blog.coldwind.top/posts/why-we-need-valuetask/","title":"为什么我们需要 ValueTask？"},{"content":"using 语句在 C# 中有很多种用法，比如引入命名空间，为类型起别名，或者释放资源等。这篇文章我们主要讨论 using 语句在释放资源时的陷阱。\nusing 以前的使用方式 \u0026para; 在很久很久以前，我们如果想要读取一个外部文本文件的内容，可能会这样写（不考虑更简洁易用的 File.ReadAllText() 等方法）：\n1 2 3 4 5 6 7 8 using (var stream = new FileStream(filename, FileMode.Open)) { using (var reader = new StreamReader(stream)) { var content = reader.ReadToEnd(); Console.WriteLine(content); } } 其实上面的代码，是可以减少一层缩进的，并且这也是各种 IDE 推荐的写法，形如：\n1 2 3 4 5 6 using var stream = new FileStream(filename, FileMode.Open) using var reader = new StreamReader(stream) { var content = reader.ReadToEnd(); Console.WriteLine(content); } 这个其实很有意思，因为一般我们都认为，即便外层的语句省略了花括号，内层的语句依旧会保持缩进，就比如多层 if 语句：\n1 2 3 4 5 if (condition1) if (condition2) { // do something } 但是上面展示的 using 的省略外层花括号的新语法，内层的语句并不会额外添加缩进，而是会与外层保持同一层级。不信的话，可以使用任意一个格式化工具，比如 Visual Studio 的 Ctrl+K, Ctrl+D，格式化一下上面的代码，看看会是什么样子。\nusing 的新语法 \u0026para; C# 8.0 为我们带来了一个新的 using 语句的用法，可以减少一层缩进，让代码看起来更简洁。同样是上面的代码，现在可以写成：\n1 2 3 4 5 6 string filename = \u0026#34;test.txt\u0026#34;; using var stream = new FileStream(filename, FileMode.Open); using var reader = new StreamReader(stream); var content = reader.ReadToEnd(); Console.WriteLine(content); 上面的代码实际上会被编译为这样的 low-level C# 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 string path = \u0026#34;test.txt\u0026#34;; FileStream fileStream = new FileStream(path, FileMode.Open); try { StreamReader streamReader = new StreamReader(fileStream); try { string value = streamReader.ReadToEnd(); Console.WriteLine(value); } finally { if (streamReader != null) { ((IDisposable)streamReader).Dispose(); } } } finally { if (fileStream != null) { ((IDisposable)fileStream).Dispose(); } } 不难看出，using 语句用于资源释放时，其实是通过 try-finally 语句来实现的。当存在多层的 using 语句时，每一层都会对应一个 try-finally 语句，也就变成了上面的样子。\n新的语法会将 using 语句下面的内容（准确地说，是当前作用域中剩下的代码）包装在 try-finally 语句中，从而保证代码在离开作用域前，会释放资源。\nInfo\r仔细观察还可以发现，Dispose 的顺序是从内到外的，或者说先被 using 的对象会后被释放。\r新语法的陷阱 \u0026para; 学了这个新语法之后，相信很多人都打算全面替代掉旧方法，毕竟少写了花括号，而且减少了缩进，效果还一模一样。但实际上，这种新语法并不是适用于所有情况的。也就是说，效果未必一模一样。比如之前我就踩了一个坑。\n当时的情况是，我在使用 System.IO.Compression 命名空间下的 GZipStream 来压缩一个文本，并输出压缩后的内容。我使用的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 using System.IO.Compression; using System.Text; string input = \u0026#34;text to be compressed.\u0026#34;; using var outputStream = new MemoryStream(); using var inputStream = new MemoryStream(Encoding.UTF8.GetBytes(input)); using var compressor = new GZipStream(outputStream, CompressionLevel.Optimal); inputStream.CopyTo(compressor); var compressed = outputStream.ToArray(); Console.WriteLine(compressed.Length); 运行后，输出了压缩后的内容长度为 10。\n但是当我修改了 input 的字符串内容后，发现输出的长度依旧是 10，这显然是不可能的。我检查了一下代码，发现问题出在了 using 语句上。只要把上面的代码修改成这样，就能得到正确的结果：\n1 2 3 4 5 6 7 8 using var outputStream = new MemoryStream(); using (var inputStream = new MemoryStream(Encoding.UTF8.GetBytes(input))) using (var compressor = new GZipStream(outputStream, CompressionLevel.Optimal)) { inputStream.CopyTo(compressor); } var compressed = outputStream.ToArray(); Console.WriteLine(compressed.Length); 造成这一现象的原因是，如果想要得到正确的压缩后的内容，需要保证 GZipStream 已经被释放。但是如果我们不加声明 GZipStream 这一行的花括号，会导致它直到离开作用域时才被释放，而不是在 inputStream.CopyTo(compressor) 之后立即释放。\n所以，大家在使用新的 using 语句时，一定要根据实际情况来判断是否适用，不要无脑替换掉以前的旧写法。\n","date":"2024-04-11T00:00:00Z","image":"https://s2.loli.net/2024/04/11/lbxw86NGjKJyqAv.jpg","permalink":"https://blog.coldwind.top/posts/using-statement-trap/","title":"Using 语句的陷阱"},{"content":" 什么是“鸭子类型”？ \u0026para; 鸭子类型的名字来源于一句俚语：\n如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子。\n这句话的意思是，如果一个对象具有某个方法或属性，那么它就可以被当作拥有这个方法或属性的类型来使用，而不需要严格地遵循一些规定与要求。\n在 C# 中，通常我们会认为，如果想要使用一些语法，需要实现一些接口。比如你很可能会觉得：\n如果想要使用 foreach 语句，需要实现 IEnumerable 接口 如果想要使用 await 语句，需要与 Task 类或一些底层接口扯上关系 如果想要使用 using 语句释放资源，需要实现 IDisposable 接口 实际上真的如此吗？这篇文章我们就来总结一下 C# 中的那些不为人知的鸭子类型。\nC# 中的鸭子类型 \u0026para; foreach 语句 \u0026para; C# 标准库为我们提供了大量的集合类型，比如 List、Stack、Queue、ObservableCollection 等等。这些集合类型都实现了 IEnumerable 接口，所以我们可以使用 foreach 语法来遍历它们。\n但实际上，foreach 语法并不要求类必须实现 IEnumerable 接口。只要类中有一个名为 GetEnumerator 的方法，返回一个 IEnumerator 类型的对象，就可以使用 foreach 语法。比如下面这个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var c = new MyEnumerableClass(); foreach (var item in c) { Console.WriteLine(item); } class MyEnumerableClass { private int[] items = new[] { 1, 2, 3 }; public IEnumerator GetEnumerator() { return items.GetEnumerator(); } } 我们还可以玩一些“花活”。事实上，这个 GetEnumerator 方法其实都不需要直接出自这个类型，甚至可以是一个扩展方法。所以，我们可以对一些我们无法修改的类添加扩展方法，从而使它们变得可以被 foreach 语法遍历。比如 C# 8.0 引入了 Range 与 Index 两个类型，表示数组的范围与索引。\nInfo\r通常我们不会直接声明一个 Range 对象，而是会使用形如 array[1..5] 这样的语法来表示一个范围。在底层，这个 1..5 会被转换为一个 Range 对象。\n你甚至可以不在数组的索引器中使用这个语法，而是直接声明一个变量并这样进行赋值：\n1 2 var range = 1..5; Console.WriteLine(range.GetType().Name); // Range 我们可以为 Range 类型添加一个扩展方法，使得它们可以被 foreach 语法遍历：\n1 2 3 4 5 6 7 8 static class MyExtensions { public static IEnumerator\u0026lt;int\u0026gt; GetEnumerator(this Range range) { for (int i = range.Start.Value; i \u0026lt;= range.End.Value; i++) yield return i; } } 然后就可以这样玩了：\n1 2 3 4 5 6 7 8 9 foreach (var i in 1..3) // 1..3 是一个 Range 类型 { Console.WriteLine(i); } // 输出： // 1 // 2 // 3 await 语句 \u0026para; 类似地，await 语法也不要求类必须继承 Task 类或实现一些底层接口。只要类中有一个名为 GetAwaiter 的方法，返回一个 IAwaiter 类型的对象，就可以使用 await 语法。并且与上面 foreach 的例子相同，我们也可以把 GetAwaiter 方法定义为一个扩展方法，从而“扩展”一些我们无法修改的类。\n1 2 3 4 5 static class Extensions { public static TaskAwaiter GetAwaiter(this TimeSpan ts) =\u0026gt; Task.Delay(ts).GetAwaiter(); public static TaskAwaiter GetAwaiter(this double sec) =\u0026gt; Task.Delay(TimeSpan.FromSeconds(sec)).GetAwaiter(); } 上面的静态类中声明了两个扩展方法，分别为 TimeSpan 与 double 类型添加了 GetAwaiter 方法。然后我们就可以这样使用 await 语法了：\n1 2 await TimeSpan.FromSeconds(1); await 1.0; 是不是感觉越来越离谱了？不过实际开发中，轻易还是不要使用这样的技巧，因为这会严重污染常用的类型，可以说是有百害而无一利。\nusing 语句 \u0026para; 如果你认为 using 语句只能用于实现了 IDisposable 接口的类，那你终于基本上对了一次😂。的确，对于一个 class 类型的对象，如果它没有实现 IDisposable 接口，那么即便它拥有 public void Dispose() 方法，它仍然是无法使用 using 语句的（编译器会提示，这个对象必须可以隐式转换为 IDisposable 对象）。\n但是！\nC# 中还有一个不太常用的 ref struct 类型。这种类型的对象在离开作用域时会自动被销毁，所以它们不需要实现 IDisposable 接口。即便如此，我们可以为这种类型的对象添加一个 Dispose 方法，这样我们就可以使用 using 语句来释放资源了。\n1 2 3 4 5 6 7 8 9 ref struct MyDisposableStructType { public void Dispose() { Console.WriteLine(\u0026#34;MyDisposableStructType Disposed.\u0026#34;); } } using var s = new MyDisposableStructType(); 这样的话，我们就可以对一个没有实现 IDisposable 接口的对象使用 using 语句了。\n集合初始化器 \u0026para; C# 中的很多集合类型都支持集合初始化器语法 { } 来初始化集合对象。比如 List 类型可以这样初始化：\n1 var list = new List\u0026lt;int\u0026gt; { 1, 2, 3 }; 实际上，只要类实现了 IEnumerable 接口，并且包含一个名为 Add 的方法，那么这个类就可以使用集合初始化器语法。比如下面这个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class PlanetCollection\u0026lt;T\u0026gt; : IEnumerable { public T[] Planets { get; init; } private int _index = 0; public PlanetCollection(int count) { Planets = new T[count]; } public void Add(T item) { if (_index \u0026gt;= Planets.Length) throw new IndexOutOfRangeException(); Planets[_index++] = item; } public IEnumerator GetEnumerator() =\u0026gt; Planets.GetEnumerator(); } 然后我们就可以这样初始化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var collection = new PlanetCollection\u0026lt;string\u0026gt;(8) { \u0026#34;mercury\u0026#34;, \u0026#34;venus\u0026#34;, \u0026#34;earth\u0026#34;, \u0026#34;mars\u0026#34;, \u0026#34;jupiter\u0026#34;, \u0026#34;saturn\u0026#34;, \u0026#34;uranus\u0026#34;, \u0026#34;neptune\u0026#34; }; // 会被编译为： PlanetCollection\u0026lt;string\u0026gt; source = new PlanetCollection\u0026lt;string\u0026gt;(8); source.Add(\u0026#34;mercury\u0026#34;); source.Add(\u0026#34;venus\u0026#34;); source.Add(\u0026#34;earth\u0026#34;); source.Add(\u0026#34;mars\u0026#34;); source.Add(\u0026#34;jupiter\u0026#34;); source.Add(\u0026#34;saturn\u0026#34;); source.Add(\u0026#34;uranus\u0026#34;); source.Add(\u0026#34;neptune\u0026#34;); 元组拆分 \u0026para; C# 在引入了元组后，也引入了元组拆分语法。比如我们可以这样写：\n1 2 var (a, b) = (1, 2); (int c, int d) = (3, 4); 很多原生的类型也支持元组拆分。比如：\n1 2 3 4 5 var pair = new KeyValuePair\u0026lt;string, int\u0026gt;(\u0026#34;key\u0026#34;, 42); var (key, value) = pair; var dt = DateTime.Now; var (year, month, day) = dt; 此外，如果我们声明一个 record 类型，那么底层也会为我们提供元组拆分的功能。\n实际上，元组拆分的语法是通过 Deconstruct 方法实现的。只要类中有一个名为 Deconstruct 的方法，并且用 out 的方式进行传参，那么这个类就可以使用元组拆分语法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Point2d { public int X { get; set; } public int Y { get; set; } public void Deconstruct(out int x, out int y) { x = X; y = Y; } } var point = new Point2d { X = 1, Y = 2 }; var (x, y) = point; LINQ 的 SelectMany 方法 \u0026para; 最后再说一个比较冷门且不常用的，就是 LINQ 中的 SelectMany 方法，以及多层 from 语句。比如我们现在有一个“数组的数组”一样的结构，例如：\n1 2 3 4 5 6 7 8 9 10 class Person { public string Name { get; set; } public List\u0026lt;Pet\u0026gt; Pets { get; set; } } class Pet { public string Name { get; set; } } 我们可以使用 SelectMany 方法来展开这个结构：\n1 2 3 4 5 6 7 var people = GetPeople(); // 使用查询表达式 var pets = (from person in people from pet in person.Pets select pet).ToList(); // 或者链式表达式 var pets = people.SelectMany(p =\u0026gt; p.Pets).ToList(); 实际上，只要我们为类提供正确的 SelectMany 方法，那么我们就可以使用多层 from 语句来展开这个结构。比如我们可以为上面集合初始化器中的 PlanetCollection 类型提供一个 SelectMany 方法，从而展开这个结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 static class Extensions { public static IEnumerable\u0026lt;TResult\u0026gt; SelectMany\u0026lt;TSource, TCollection, TResult\u0026gt;( this PlanetCollection\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, IEnumerable\u0026lt;TCollection\u0026gt;\u0026gt; collectionSelector, Func\u0026lt;TSource, TCollection, TResult\u0026gt; resultSelector ) { foreach (var item in source.Planets) { foreach (var subItem in collectionSelector(item)) { yield return resultSelector(item, subItem); } } } } var query = from planet in collection from letter in planet select letter; Console.WriteLine(new string(query.ToArray()).ToUpper()); 这个 SelectMany 方法的要求相对比较复杂，这里我们就不展开讨论了。\n总结 \u0026para; 看了这篇文章之后，相信大家会对 C# 这门编程语言有一个更新的认识了吧？\n事实上，上面提到的大多数鸭子类型，都是与底层 C# 代码密不可分的。这里我给大家提供一个探索的方向，比如可以借助 SharpLab 这样的工具，查看诸如 foreach 语句、await 语句、以及集合初始化器等语法对应的底层 C# 代码。相信大家一定会有所收获。\n","date":"2024-04-04T00:00:00Z","image":"https://s2.loli.net/2024/04/11/SIRUGn7OflgEWsr.jpg","permalink":"https://blog.coldwind.top/posts/csharp-duck-types/","title":"C# 鸭子类型汇总"},{"content":" 安装 EntityFrameworkCore \u0026para; 以 Sql Server 为例，可以在 NuGet 包管理器中搜索并安装以下包：\nMicrosoft.EntityFrameworkCore Microsoft.EntityFrameworkCore.SqlServer 实现 Model \u0026para; 假定现在有这样一张表：\n1 2 3 4 5 6 CREATE TABLE [dbo].[Blog] ( [BlogId] INT IDENTITY (1, 1) NOT NULL, [Title] NVARCHAR (100) NULL, [Author] NVARCHAR (50) NULL, [Content] NVARCHAR (MAX) NULL, ); 可以创建一个对应的 Model：\n1 2 3 4 5 6 7 public class Blog { public int BlogId { get; set; } public string Title { get; set; } public string Author { get; set; } public string Content { get; set; } } 创建 DbContext \u0026para; 创建一个继承自 DbContext 的类：\n1 2 3 4 public class BloggingContext : DbContext { public DbSet\u0026lt;Blog\u0026gt; Blogs { get; set; } } 这里其实幕后发生了一些基于 EF 命名习惯的自动配置，比如：\nBlog 类对应的表名为其复数形式 Blogs BlogId 字段会被自动识别为主键 配置连接字符串 \u0026para; 最简单的方法是直接重写 OnConfiguring 方法：\n1 2 3 4 5 6 7 class BloggingContext : DbContext { protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder.UseSqlServer(@\u0026#34;Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=Blogging;\u0026#34;); } } 使用 DbContext \u0026para; 获取 Blog 数据：\n1 2 3 4 using (var db = new BloggingContext()) { var blogs = db.Blogs.ToList(); } 添加新的 Blog：\n1 2 3 4 5 using (var db = new BloggingContext()) { db.Blogs.Add(new Blog { Title = \u0026#34;Hello World\u0026#34;, Author = \u0026#34;Alice\u0026#34;, Content = \u0026#34;Hello World!\u0026#34; }); db.SaveChanges(); } 总结 \u0026para; 在本文中，我们通过一个最小化的示例介绍了如何使用 Entity Framework Core 进行数据访问。我们创建了一个 BloggingContext 类来表示数据库上下文，并定义了一个 DbSet\u0026lt;Blog\u0026gt; 来操作 Blog 实体。我们还展示了如何配置连接字符串，以及如何使用 DbContext 来添加和获取数据。\n这个简单的例子虽然只涉及到了基本的操作，但它为理解 EF Core 的工作原理和进一步探索其功能提供了基础。\n感谢阅读，欢迎在评论区分享你的想法和问题。\n","date":"2024-03-13T00:00:00Z","permalink":"https://blog.coldwind.top/posts/efcore-minimal-example/","title":"EntityFrameworkCore 最小入门指南"},{"content":"Benchmark.NET 是一个用于 .NET 应用程序的强大的基准测试库。它可以帮助开发人员评估他们的代码的性能，找出潜在的性能问题，并且比较不同的实现方式。Benchmark.NET 提供了丰富的特性，包括内存诊断、全局初始化、迭代初始化等，可以满足各种性能测试的需求。\n这篇文章将介绍 Benchmark.NET 的基础知识和一些常用的特性。你也可以观看我的 B 站教学视频进行学习。\n常用特性 \u0026para; 一些常用的特性：\nClass MemoryDiagnoser：查看内存分配情况（有一个 bool 参数，表示是否显示 GC 的情况） SimpleJob：可以设置 .NET 版本，如 RuntimeMoniker.Net60 Orderer(SummaryOrderPolicy.SlowestToFastest)：输出结果的排序 RankColumn：为结果表格添加一列 Rank，表示当前行的方法的排名 Method Benchmark：表示这个方法需要被测试（另有一个 Baseline 参数，同时会给结果添加一列 Ratio，表示和 Baseline 的比率） Arguments：类似于 Params，表示该方法的传参，可以有多个，并且会和 Params 联动，充分考虑各种组合 GlobalSetup：全局初始化，常用于初始化一个要用来测试的变量、集合等。可以和 Params 联动，比如数组的容量由某个字段决定 IterationSetup：用于在每次迭代前的初始化，每次迭代都会调用一次 Field Params：某个字段可能有不同的值（如果多个字段被标记该特性，则会充分考虑所有参数的组合） 实际例子 \u0026para; 测试排序的效率 \u0026para; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [MemoryDiagnoser] public class SortTester { private List\u0026lt;int\u0026gt; testList; [GlobalSetup] public void Setup() { testList = Enumerable.Range(1, 100).Shuffle(new Random(1334)).ToList(); } [Benchmark] public List\u0026lt;int\u0026gt; ListSort() { var lst = new List\u0026lt;int\u0026gt;(testList); lst.Sort(); return lst; } [Benchmark] public List\u0026lt;int\u0026gt; LinqOrder() { return testList.Order().ToList(); } } 测试初始化数组的效率 \u0026para; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class ListInit { [Params(16, 128, 1060)] public int count; [Benchmark(Baseline = true)] public List\u0026lt;int\u0026gt; WithoutInit() { var res = new List\u0026lt;int\u0026gt;(); for (int i = 0; i \u0026lt; count; i++) res.Add(i); return res; } [Benchmark] public List\u0026lt;int\u0026gt; WithInit() { var res = new List\u0026lt;int\u0026gt;(count); for (int i = 0; i \u0026lt; count; i++) res.Add(i); return res; } [Benchmark] public List\u0026lt;int\u0026gt; WithLinq() { return Enumerable.Range(0, count).ToList(); } } .NET 6 vs. .NET 7 \u0026para; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [MemoryDiagnoser(false)] [SimpleJob(RuntimeMoniker.Net60)] [SimpleJob(RuntimeMoniker.Net70)] public class SortTester { private IEnumerable\u0026lt;int\u0026gt; testList; [GlobalSetup] public void Setup() { testList = Enumerable.Range(1, 10).ToArray(); } [Benchmark] public int CalcMin() { return testList.Min(); } } 注意事项 \u0026para; 要使用有编译器优化的 Release 模式 被测试的类、使用了特性的方法与字段均需要为 public 在要测试的方法中尽量避免会被 JIT 优化掉的情况，比如有一个不会被使用的变量等 除非还想要测试内存读取的速度等，否则一般没有必要创建过大的数组 参考链接 \u0026para; Rules of benchmarking - BenchmarkDotNet Documentation\n","date":"2024-03-05T10:52:37+08:00","permalink":"https://blog.coldwind.top/posts/benchmark-dotnet/","title":"Benchmark.NET 简易指南"},{"content":" 简介 \u0026para; CSharpier 是一个针对 C# 代码的格式化工具，它可以帮助开发者自动化地调整代码的格式，使其更加一致和易于阅读。CSharpier 提供了丰富的配置选项，可以根据项目的需求定制代码格式化的规则。\n它的官方介绍是「CSharpier is an opinionated code formatter for C#」，其中的“opinionated”是一个英文词，意思是“有主见的”或“有偏见的”。它想表达的是，该工具对代码格式化有自己的偏好和主见，即它会按照自己的规则来格式化代码，而不是完全按照用户的意愿。在下面的内容中，大家不难看出，CSharpier 几乎没有提供多少可以配置的选项。\n安装 \u0026para; 在 VS 的扩展中安装了 CSharpier 后，重启 VS 后会在上方提示安装工具，但是也可以自行安装，方式如下：\n1 dotnet tool install -g csharpier 如果希望更新，那么可以：\n1 dotnet tool update -g csharpier 除了 VS，VS Code、Rider 中也都有同名的扩展。\n配置 \u0026para; 可以在项目的根目录（通常与 .sln 文件位置相同）创建一个配置文件，可以是下面三个的任意一种：\n.csharpierrc .csharpierrc.json .csharpierrc.yaml 支持的配置项非常少，常用的一些如下：\n1 2 3 4 5 6 { \u0026#34;printWidth\u0026#34;: 100, \u0026#34;useTabs\u0026#34;: false, \u0026#34;tabWidth\u0026#34;: 4, \u0026#34;preprocessorSymbolSets\u0026#34;: [\u0026#34;\u0026#34;, \u0026#34;DEBUG\u0026#34;, \u0026#34;DEBUG,CODE_STYLE\u0026#34;] } 或者\n1 2 3 4 5 6 7 printWidth: 100 useTabs: false tabWidth: 4 preprocessorSymbolSets: - \u0026#34;\u0026#34; - \u0026#34;DEBUG\u0026#34; - \u0026#34;DEBUG,CODE_STYLE\u0026#34; 其中最后一个配置项与代码中预编译器指令（如 #if DEBUG）有关，详见官方的配置文档。\n实用场景 \u0026para; 这里我随便写了一大段 C# 代码，大家可以拷贝到自己常用的 C# 开发工具中，然后使用 CSharpier 格式化，从而查看效果。\nCSharpier 还提供了一个Playground，方便大家在线体验它的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class CSharpierDemo { private readonly List\u0026lt;string\u0026gt; allowedExtensions = new List\u0026lt;string\u0026gt; { \u0026#34;.jpg\u0026#34;, \u0026#34;.jpeg\u0026#34;, \u0026#34;.png\u0026#34;, \u0026#34;.gif\u0026#34;, \u0026#34;.bmp\u0026#34;, \u0026#34;.tiff\u0026#34;, \u0026#34;.tif\u0026#34;, \u0026#34;.webp\u0026#34;, \u0026#34;.heic\u0026#34; }; private int[,] map = new [,] { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; public static readonly DependencyProperty MyPropertyProperty = DependencyProperty.Register(\u0026#34;MyProperty\u0026#34;, typeof(string), typeof(MyControl), new PropertyMetadata(\u0026#34;\u0026#34;)); [JsonIgnore] public string MyProperty1 { get; set; } [JsonIgnore] public string MyProperty2 { get; set; } [JsonIgnore] public string MyProperty3 { get; set; } private void Foo() { allowedExtensions.Select(x =\u0026gt; x.Trim().ToLower()).Select(x =\u0026gt; x.TrimLeft(\u0026#39;.\u0026#39;)).Where(x =\u0026gt; x.Length == 3).ToList().ForEach(x =\u0026gt; Console.WriteLine(x)); var exts = from x in allowedExtensions select x.Trim().ToLower() into x select x.TrimLeft(\u0026#39;.\u0026#39;) into x where x.Length == 3 select x; } private void FooWithManyParameters([FromHeader(Name = \u0026#34;Id\u0026#34;)] long id, [FromQuery(Name = \u0026#34;first_name\u0026#34;)] string firstName, [FromQuery(Name = \u0026#34;last_name\u0026#34;)] string lastName, string? middleName = null, Action? callback = null, Action? errorCallback = null) { // ... } } ","date":"2023-10-16T00:00:00Z","image":"https://s2.loli.net/2024/04/14/qZeQzEnSDvWpPyL.png","permalink":"https://blog.coldwind.top/posts/csharpier/","title":"C# 代码格式化工具 CSharpier 上手指南"},{"content":".NET 开发这一领域有一款特别有名的小工具名叫 LINQPad，是一位国外技术大牛开发的软件，能够显著提高 .NET 工程师的效率，但是价格也一点不便宜。除了（基本上是个半残的）免费版，还有专业版、开发者版以及尊享版，而我买的就是最贵的版本，$115，按照当时的汇率，足足 800+ RMB。但是我认为买得很值。我一直在用，它帮上了大忙，那么我觉得它是完全值得我花这笔钱的。\n不仅如此，我还觉得这款软件在国外非常火爆，在国内却鲜有人知道，所以我专门制作了一期视频分享给了大家。\n不久之后，我就看到了评论区这么一条内容：\n这条评论我觉得真是又好气又好笑。这句话实在是不合逻辑，槽点太多，也让我看到了一些人对于所谓的付费软件以及程序员群体有着怎样的误解。\n只适合专业程序员？ \u0026para; 首先第一条，什么叫“可惜太贵，只适合专业程序员”？意思是说，不专业的程序员，或者学生党之类的就不适合？这款软件虽然最高一档的价值 800+，但是免费版也凑活着能用啊？或者你咬咬牙，花个不到 400 元就可以买一个专业版了。讲道理，400 块算多吗？放在氪金手游里面，怕不是只能抽出来一些卡池里面的乐色吧？我现在上班，每天光是坐地铁就要 10 元，一个月就是 200 多；每天三餐要花三四十，一个月就要 1000 块；这年头手机的话费，一年怎么着不得 400+？为什么这些都像是习以为常的东西，眼前的一款买断制的软件你却下不了手了？\n更重要的是，买了这款软件，它可以帮助你不说一辈子了，最起码在接下来几年的学习工作生涯的黄金期里助你一臂之力，大幅提高工作学习的效率，明显发挥出软件自身的价值，难道不比你买一个氪个什么 328、648 要有意义得多？\n程序员不在乎这点钱？ \u0026para; 第二条，什么叫“程序员不在乎这点钱”？意思是说程序员都是高薪行业的人才，一个个月入好几万，根本不会在乎这么一丁点钱？不好意思，你又错了。首先，程序员就不是你想象中的这么高薪。或许能月入个一万多，但是大都是在北上广深这些地方，每月光是房租就要花个好几千，最后算下来也不剩多少了。就这还是拿身体换来的，一个个年纪轻轻地就眼睛也不好了，颈椎腰椎也不好了，手腕也不好了，头发也不剩多少了。所以程序员也不见得就不在乎这点钱的。\n这种说的还是单身的没有梦想成为咸鱼的程序员。如果想结婚生子，想买房买车，想提升自己，给自己买个网课、健身房会员卡什么的，那更是开支大了去了。你月入 40K 又如何？说不定月供就两三万。所以专业程序员就不差钱了？真是想太多了。\n不差钱的程序员就会愿意掏钱？ \u0026para; 再然后，“他们不差这点钱”，所以他们就“适合买这款软件了”？不好意思，我身边“在乎这点钱”的程序员多了去了。我认识一位程序员，每周工作日至少喝三四杯国内某知名连锁店铺的奶茶，每杯按 18 块算，一个月最少也要 200 多块了。但是咧，人家连 Office 用的都是盗版的 2010，整天标题栏都是大红色的，连个京东淘宝上搞活动 200 多块的正版 Office 365（后来改名叫 Microsoft 365 了）都舍不得买，即便人家每天到手的工资都够买原价的 365 了。这种人有可能会愿意花好几百买一款没有任何开发功能，只是方便自己工作学习的小软件？\n我身边这样的程序员真的是不少。我推荐他们用 XMind，明明这玩意有免费的试用版，但是他们就是喜欢一上去就在百度搜索破解版，最后下了个盗版的 XMind 8；开发软件用的 IDE，直接去搜个破解版 JetBrains 系列的，都不知道有免费的 Visual Studio 社区版以及 Visual Studio Code 可以用的；iPad 上看 PDF 记个笔记或者画个画，连个 Notability 或者 Procreate 都舍不得买，非得去找个多人共用的苹果账号用“分享版”的，不知道哪天 APP 就不能更新了。那我要是推荐他们去用 LINQPad，不用说，肯定去找盗版了，明明还有一个免费的平替 RoslynPad。\n所以我想说的是，并不是所有程序员都不觉得这笔钱不是钱，也并不是所有程序员在买得起这款软件的情况下就会愿意掏钱。退一步说，就算是舍不得买正版，也不代表你就要去用盗版啊？我买不起正版 PS，但我买得起 Affinity Photo；我买不起 PR，但我可以用免费的 DaVinci；买不起 Office，但还可以用 WPS（如果你能接受广告什么的）或者 LibreOffice；买不起 LINQPad，那还可以用平替的 RoslynPad，或者不然就在 VS 里面新建一个 Console App 呗。\n到底什么样的人适合这款软件？ \u0026para; 那到底什么样的人才适合这款软件呢？我开头就已经说了，这款软件可以帮到这个行业的所有人群，不论你的技术是强还是弱，你的钱包是鼓还是瘪。只要你有着一颗想要提升自己的心，以及对正版优质软件的认可，那么我都认为你可以去买这款软件。\n而这样的人恐怕并不是很多。有的图像工作者，已经依靠修图挣了很多钱，却不愿买正版的 PS；有的音乐工作者，依靠编曲已经足够养家糊口，但依旧不愿意买个正版 FL；有的程序员，已经依靠写代码挣了这么多钱，却依旧不愿意为他们使用的软件付个费，凡事总是想着去搜索破解版，甚至不以为耻，反而觉得占到了多大的便宜。当然还有些蠢货觉得这都是外国软件，跟境外势力有什么好客气的，或者“慈禧太后当年都把钱给掏过了”之类，那我真是无 f*ck 说。\n曾经有一个同事得知我用的是每年花费好几百的正版 Office 订阅，觉得不以为然，说自己用的是破解版，不照样可以用吗，还省下了不少钱。我没有回答他，但是我有一句差点到嘴边了的话被我给咽了回去：请问你每年比我省下了好几百，那么你比我多得到了什么呢？\n到底能不能用盗版软件？ \u0026para; 最后，我想聊的是，盗版软件到底能不能用？我认为可以用，但是要时刻知道这样做是不对的。Minecraft《我的世界》（以下简称 MC）是一款全球知名的沙盒类游戏，但是正版是要钱的。有一位学生写信给 MC 的创始人 Notch 说，自己想玩 MC，但是没有足够的钱，问能不能玩盗版的？Notch 笑着回答说，可以玩，但是要怀着愧疚的心。\n你如果对这款软件实际的效果不够放心，那你大可以去找一个破解版，然后用上一段时间（虽然它本身也提供了 30 天无条件退款）。如果你觉得这个软件不行，那你可以不去用它；如果你觉得这款软件不错，那你可以选择付费；但是你不能就这么一直用着盗版。用一段时间的盗版之后，如果觉得软件确实很好，那么我相信，善良正直的你，会选择为这款优秀的软件补票的。\n这也正是我对那些使用破解版软件的人的建议。\n","date":"2022-12-25T00:00:00Z","image":"https://s2.loli.net/2024/04/20/9dsCD7m1FJBQKZz.png","permalink":"https://blog.coldwind.top/posts/use-pirate-with-guilty/","title":"可以用盗版，但是要怀着愧疚的心"}]